
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Indexing &#8212; NumPy v1.21 Manual</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.f6b7ca918bee2f46fd9abac01cfb07d5.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1e043a052b0af929e4d8.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="I/O with NumPy" href="basics.io.html" />
    <link rel="prev" title="Array creation" href="basics.creation.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
<link rel="stylesheet" href="../_static/numpy.css" type="text/css" />

    <!-- PR #17220: This is added via javascript in versionwarning.js  -->
    <!-- link rel="canonical" href="http://numpy.org/doc/stable/user/basics.indexing.html" / -->


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">


    
      
      <a class="navbar-brand" href="../index.html">
        <img src="../_static/numpylogo.svg" class="logo" alt="logo">
      </a>      
      
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    
    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        <li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dev/index.html">
  Development
 </a>
</li>

        
      </ul>

      <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/numpy/numpy" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/numpy_team" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l2">
  <a class="reference internal" href="whatisnumpy.html">
   What is NumPy?
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference external" href="https://numpy.org/install/">
   Installation
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="quickstart.html">
   NumPy quickstart
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="absolute_beginners.html">
   NumPy: the absolute basics for beginners
  </a>
 </li>
 <li class="toctree-l2 current active">
  <a class="reference internal" href="basics.html">
   NumPy fundamentals
  </a>
  <ul class="current">
   <li class="toctree-l3">
    <a class="reference internal" href="basics.creation.html">
     Array creation
    </a>
   </li>
   <li class="toctree-l3 current active">
    <a class="current reference internal" href="#">
     Indexing
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="basics.io.html">
     I/O with NumPy
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="basics.types.html">
     Data types
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="basics.broadcasting.html">
     Broadcasting
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="basics.byteswapping.html">
     Byte-swapping
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="basics.rec.html">
     Structured arrays
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="basics.dispatch.html">
     Writing custom array containers
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="basics.subclassing.html">
     Subclassing ndarray
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="misc.html">
   Miscellaneous
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="numpy-for-matlab-users.html">
   NumPy for MATLAB users
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="building.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="c-info.html">
   Using NumPy C-API
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="tutorials_index.html">
   NumPy Tutorials
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="howtos_index.html">
   NumPy How Tos
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="depending_on_numpy.html">
   For downstream package authors
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="../f2py/index.html">
   F2PY Users Guide and Reference Manual
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="../glossary.html">
   Glossary
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="../dev/underthehood.html">
   Under-the-hood Documentation for developers
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="../docs/index.html">
   NumPy’s Documentation
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="../bugs.html">
   Reporting bugs
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="../release.html">
   Release Notes
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="../doc_conventions.html">
   Documentation conventions
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="../license.html">
   NumPy license
  </a>
 </li>
</ul>
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#assignment-vs-referencing">
   Assignment vs referencing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#single-element-indexing">
   Single element indexing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#other-indexing-options">
   Other indexing options
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#index-arrays">
   Index arrays
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#indexing-multi-dimensional-arrays">
   Indexing Multi-dimensional arrays
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#boolean-or-mask-index-arrays">
   Boolean or “mask” index arrays
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#combining-index-arrays-with-slices">
   Combining index arrays with slices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#structural-indexing-tools">
   Structural indexing tools
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#assigning-values-to-indexed-arrays">
   Assigning values to indexed arrays
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dealing-with-variable-numbers-of-indices-within-programs">
   Dealing with variable numbers of indices within programs
  </a>
 </li>
</ul>

</nav>


              
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="indexing">
<span id="basics-indexing"></span><h1>Indexing<a class="headerlink" href="#indexing" title="Permalink to this headline">¶</a></h1>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../reference/arrays.indexing.html#arrays-indexing"><span class="std std-ref">Indexing</span></a></p>
<p><a class="reference internal" href="../reference/routines.indexing.html#routines-indexing"><span class="std std-ref">Indexing routines</span></a></p>
</div>
<p>Array indexing refers to any use of the square brackets ([]) to index
array values. There are many options to indexing, which give NumPy
indexing great power, but with power comes some complexity and the
potential for confusion. This section is just an overview of the
various options and issues related to indexing. Aside from single
element indexing, the details on most of these options are to be
found in related sections.</p>
<div class="section" id="assignment-vs-referencing">
<h2>Assignment vs referencing<a class="headerlink" href="#assignment-vs-referencing" title="Permalink to this headline">¶</a></h2>
<p>Most of the following examples show the use of indexing when
referencing data in an array. The examples work just as well
when assigning to an array. See the section at the end for
specific examples and explanations on how assignments work.</p>
</div>
<div class="section" id="single-element-indexing">
<h2>Single element indexing<a class="headerlink" href="#single-element-indexing" title="Permalink to this headline">¶</a></h2>
<p>Single element indexing for a 1-D array is what one expects. It work
exactly like that for other standard Python sequences. It is 0-based,
and accepts negative indices for indexing from the end of the array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="go">8</span>
</pre></div>
</div>
<p>Unlike lists and tuples, NumPy arrays support multidimensional indexing
for multidimensional arrays. That means that it is not necessary to
separate each dimension’s index into its own set of square brackets.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># now x is 2-dimensional</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">9</span>
</pre></div>
</div>
<p>Note that if one indexes a multidimensional array with fewer indices
than dimensions, one gets a subdimensional array. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([0, 1, 2, 3, 4])</span>
</pre></div>
</div>
<p>That is, each index specified selects the array corresponding to the
rest of the dimensions selected. In the above example, choosing 0
means that the remaining dimension of length 5 is being left unspecified,
and that what is returned is an array of that dimensionality and size.
It must be noted that the returned array is not a copy of the original,
but points to the same values in memory as does the original array.
In  this case, the 1-D array at the first position (0) is returned.
So using a single index on the returned array, results in a single
element being returned. That is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">2</span>
</pre></div>
</div>
<p>So note that <code class="docutils literal notranslate"><span class="pre">x[0,2]</span> <span class="pre">=</span> <span class="pre">x[0][2]</span></code> though the second case is more
inefficient as a new temporary array is created after the first index
that is subsequently indexed by 2.</p>
<p>Note to those used to IDL or Fortran memory order as it relates to
indexing.  NumPy uses C-order indexing. That means that the last
index usually represents the most rapidly changing memory location,
unlike Fortran or IDL, where the first index represents the most
rapidly changing location in memory. This difference represents a
great potential for confusion.</p>
</div>
<div class="section" id="other-indexing-options">
<h2>Other indexing options<a class="headerlink" href="#other-indexing-options" title="Permalink to this headline">¶</a></h2>
<p>It is possible to slice and stride arrays to extract arrays of the
same number of dimensions, but of different sizes than the original.
The slicing and striding works exactly the same way it does for lists
and tuples except that they can be applied to multiple dimensions as
well. A few examples illustrates best:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">array([2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span>
<span class="go">array([0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([1, 3, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">2</span><span class="p">,::</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[ 7, 10, 13],</span>
<span class="go">       [21, 24, 27]])</span>
</pre></div>
</div>
<p>Note that slices of arrays do not copy the internal array data but
only produce new views of the original data. This is different from
list or tuple slicing and an explicit <code class="docutils literal notranslate"><span class="pre">copy()</span></code> is recommended if
the original data is not required anymore.</p>
<p>It is possible to index arrays with other arrays for the purposes of
selecting lists of values out of arrays into new arrays. There are
two different ways of accomplishing this. One uses one or more arrays
of index values. The other involves giving a boolean array of the proper
shape to indicate the values to be selected. Index arrays are a very
powerful tool that allow one to avoid looping over individual elements in
arrays and thus greatly improve performance.</p>
<p>It is possible to use special features to effectively increase the
number of dimensions in an array through indexing so the resulting
array acquires the shape needed for use in an expression or with a
specific function.</p>
</div>
<div class="section" id="index-arrays">
<h2>Index arrays<a class="headerlink" href="#index-arrays" title="Permalink to this headline">¶</a></h2>
<p>NumPy arrays may be indexed with other arrays (or any other sequence-
like object that can be converted to an array, such as lists, with the
exception of tuples; see the end of this document for why this is). The
use of index arrays ranges from simple, straightforward cases to
complex, hard-to-understand cases. For all cases of index arrays, what
is returned is a copy of the original data, not a view as one gets for
slices.</p>
<p>Index arrays must be of integer type. Each value in the array indicates
which value in the array to use in place of the index. To illustrate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([10,  9,  8,  7,  6,  5,  4,  3,  2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">])]</span>
<span class="go">array([7, 7, 9, 2])</span>
</pre></div>
</div>
<p>The index array consisting of the values 3, 3, 1 and 8 correspondingly
create an array of length 4 (same as the index array) where each index
is replaced by the value the index array has in the array being indexed.</p>
<p>Negative values are permitted and work as they do with single indices
or slices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">])]</span>
<span class="go">array([7, 7, 4, 2])</span>
</pre></div>
</div>
<p>It is an error to have index values out of bounds:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">])]</span>
<span class="go">&lt;type &#39;exceptions.IndexError&#39;&gt;: index 20 out of bounds 0&lt;=index&lt;9</span>
</pre></div>
</div>
<p>Generally speaking, what is returned when index arrays are used is
an array with the same shape as the index array, but with the type
and values of the array being indexed. As an example, we can use a
multidimensional index array instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])]</span>
<span class="go">array([[9, 9],</span>
<span class="go">       [8, 7]])</span>
</pre></div>
</div>
</div>
<div class="section" id="indexing-multi-dimensional-arrays">
<h2>Indexing Multi-dimensional arrays<a class="headerlink" href="#indexing-multi-dimensional-arrays" title="Permalink to this headline">¶</a></h2>
<p>Things become more complex when multidimensional arrays are indexed,
particularly with multidimensional index arrays. These tend to be
more unusual uses, but they are permitted, and they are useful for some
problems. We’ll  start with the simplest multidimensional case (using
the array y from the previous examples):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])]</span>
<span class="go">array([ 0, 15, 30])</span>
</pre></div>
</div>
<p>In this case, if the index arrays have a matching shape, and there is
an index array for each dimension of the array being indexed, the
resultant array has the same shape as the index arrays, and the values
correspond to the index set for each position in the index arrays. In
this example, the first index value is 0 for both index arrays, and
thus the first value of the resultant array is y[0,0]. The next value
is y[2,1], and the last is y[4,2].</p>
<p>If the index arrays do not have the same shape, there is an attempt to
broadcast them to the same shape.  If they cannot be broadcast to the
same shape, an exception is raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])]</span>
<span class="go">&lt;type &#39;exceptions.ValueError&#39;&gt;: shape mismatch: objects cannot be</span>
<span class="go">broadcast to a single shape</span>
</pre></div>
</div>
<p>The broadcasting mechanism permits index arrays to be combined with
scalars for other indices. The effect is that the scalar value is used
for all the corresponding values of the index arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([ 1, 15, 29])</span>
</pre></div>
</div>
<p>Jumping to the next level of complexity, it is possible to only
partially index an array with index arrays. It takes a bit of thought
to understand what happens in such cases. For example if we just use
one index array with y:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])]</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5,  6],</span>
<span class="go">       [14, 15, 16, 17, 18, 19, 20],</span>
<span class="go">       [28, 29, 30, 31, 32, 33, 34]])</span>
</pre></div>
</div>
<p>What results is the construction of a new array where each value of
the index array selects one row from the array being indexed and the
resultant array has the resulting shape (number of index elements,
size of row).</p>
<p>An example of where this may be useful is for a color lookup table
where we want to map the values of an image into RGB triples for
display. The lookup table could have a shape (nlookup, 3). Indexing
such an array with an image with shape (ny, nx) with dtype=np.uint8
(or any integer type so long as values are with the bounds of the
lookup table) will result in an array of shape (ny, nx, 3) where a
triple of RGB values is associated with each pixel location.</p>
<p>In general, the shape of the resultant array will be the concatenation
of the shape of the index array (or the shape that all the index arrays
were broadcast to) with the shape of any unused dimensions (those not
indexed) in the array being indexed.</p>
</div>
<div class="section" id="boolean-or-mask-index-arrays">
<h2>Boolean or “mask” index arrays<a class="headerlink" href="#boolean-or-mask-index-arrays" title="Permalink to this headline">¶</a></h2>
<p>Boolean arrays used as indices are treated in a different manner
entirely than index arrays. Boolean arrays must be of the same shape
as the initial dimensions of the array being indexed. In the
most straightforward case, the boolean array has the same shape:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="o">&gt;</span><span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="go">array([21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34])</span>
</pre></div>
</div>
<p>Unlike in the case of integer index arrays, in the boolean case, the
result is a 1-D array containing all the elements in the indexed array
corresponding to all the true elements in the boolean array. The
elements in the indexed array are always iterated and returned in
<a class="reference internal" href="../glossary.html#term-row-major"><span class="xref std std-term">row-major</span></a> (C-style) order. The result is also identical to
<code class="docutils literal notranslate"><span class="pre">y[np.nonzero(b)]</span></code>. As with index arrays, what is returned is a copy
of the data, not a view as one gets with slices.</p>
<p>The result will be multidimensional if y has more dimensions than b.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># use a 1-D boolean whose first dim agrees with the first dim of y</span>
<span class="go">array([False, False, False,  True,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">b</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]]</span>
<span class="go">array([[21, 22, 23, 24, 25, 26, 27],</span>
<span class="go">       [28, 29, 30, 31, 32, 33, 34]])</span>
</pre></div>
</div>
<p>Here the 4th and 5th rows are selected from the indexed array and
combined to make a 2-D array.</p>
<p>In general, when the boolean array has fewer dimensions than the array
being indexed, this is equivalent to y[b, …], which means
y is indexed by b followed by as many : as are needed to fill
out the rank of y.
Thus the shape of the result is one dimension containing the number
of True elements of the boolean array, followed by the remaining
dimensions of the array being indexed.</p>
<p>For example, using a 2-D boolean array of shape (2,3)
with four True elements to select rows from a 3-D array of shape
(2,3,5) results in a 2-D result of shape (4,5):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[ 0,  1,  2,  3,  4],</span>
<span class="go">        [ 5,  6,  7,  8,  9],</span>
<span class="go">        [10, 11, 12, 13, 14]],</span>
<span class="go">       [[15, 16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23, 24],</span>
<span class="go">        [25, 26, 27, 28, 29]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [20, 21, 22, 23, 24],</span>
<span class="go">       [25, 26, 27, 28, 29]])</span>
</pre></div>
</div>
<p>For further details, consult the NumPy reference documentation on array indexing.</p>
</div>
<div class="section" id="combining-index-arrays-with-slices">
<h2>Combining index arrays with slices<a class="headerlink" href="#combining-index-arrays-with-slices" title="Permalink to this headline">¶</a></h2>
<p>Index arrays may be combined with slices. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[ 1,  2],</span>
<span class="go">       [15, 16],</span>
<span class="go">       [29, 30]])</span>
</pre></div>
</div>
<p>In effect, the slice and index array operation are independent.
The slice operation extracts columns with index 1 and 2,
(i.e. the 2nd and 3rd columns),
followed by the index array operation which extracts rows with
index 0, 2 and 4 (i.e the first, third and fifth rows).</p>
<p>This is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="p">:]</span>
<span class="go">array([[ 1,  2],</span>
<span class="go">       [15, 16],</span>
<span class="go">       [29, 30]])</span>
</pre></div>
</div>
<p>Likewise, slicing can be combined with broadcasted boolean indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">      [False, False, False, False, False, False, False],</span>
<span class="go">      [False, False, False, False, False, False, False],</span>
<span class="go">      [ True,  True,  True,  True,  True,  True,  True],</span>
<span class="go">      [ True,  True,  True,  True,  True,  True,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="n">b</span><span class="p">[:,</span><span class="mi">5</span><span class="p">],</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[22, 23],</span>
<span class="go">       [29, 30]])</span>
</pre></div>
</div>
</div>
<div class="section" id="structural-indexing-tools">
<h2>Structural indexing tools<a class="headerlink" href="#structural-indexing-tools" title="Permalink to this headline">¶</a></h2>
<p>To facilitate easy matching of array shapes with expressions and in
assignments, the np.newaxis object can be used within array indices
to add new dimensions with a size of 1. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 7)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1, 7)</span>
</pre></div>
</div>
<p>Note that there are no new elements in the array, just that the
dimensionality is increased. This can be handy to combine two
arrays in a way that otherwise would require explicitly reshaping
operations. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4, 5],</span>
<span class="go">       [2, 3, 4, 5, 6],</span>
<span class="go">       [3, 4, 5, 6, 7],</span>
<span class="go">       [4, 5, 6, 7, 8]])</span>
</pre></div>
</div>
<p>The ellipsis syntax maybe used to indicate selecting in full any
remaining unspecified dimensions. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">81</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([[29, 32, 35],</span>
<span class="go">       [38, 41, 44],</span>
<span class="go">       [47, 50, 53]])</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">,:,:,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([[29, 32, 35],</span>
<span class="go">       [38, 41, 44],</span>
<span class="go">       [47, 50, 53]])</span>
</pre></div>
</div>
</div>
<div class="section" id="assigning-values-to-indexed-arrays">
<h2>Assigning values to indexed arrays<a class="headerlink" href="#assigning-values-to-indexed-arrays" title="Permalink to this headline">¶</a></h2>
<p>As mentioned, one can select a subset of an array to assign to using
a single index, slices, and index and mask arrays. The value being
assigned to the indexed array must be shape consistent (the same shape
or broadcastable to the shape the index produces). For example, it is
permitted to assign a constant to a slice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>or an array of the right size:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that assignments may result in changes if assigning
higher types to lower types (like floats to ints) or even
exceptions (assigning complex to floats or ints):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.2</span><span class="n">j</span>
<span class="go">TypeError: can&#39;t convert complex to int</span>
</pre></div>
</div>
<p>Unlike some of the references (such as array and mask indices)
assignments are always made to the original data in the array
(indeed, nothing else would make sense!). Note though, that some
actions may not work as one may naively expect. This particular
example is often surprising to people:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 0, 10, 20, 30, 40])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 0, 11, 20, 31, 40])</span>
</pre></div>
</div>
<p>Where people expect that the 1st location will be incremented by 3.
In fact, it will only be incremented by 1. The reason is because
a new array is extracted from the original (as a temporary) containing
the values at 1, 1, 3, 1, then the value 1 is added to the temporary,
and then the temporary is assigned back to the original array. Thus
the value of the array at x[1]+1 is assigned to x[1] three times,
rather than being incremented 3 times.</p>
</div>
<div class="section" id="dealing-with-variable-numbers-of-indices-within-programs">
<h2>Dealing with variable numbers of indices within programs<a class="headerlink" href="#dealing-with-variable-numbers-of-indices-within-programs" title="Permalink to this headline">¶</a></h2>
<p>The index syntax is very powerful but limiting when dealing with
a variable number of indices. For example, if you want to write
a function that can handle arguments with various numbers of
dimensions without having to write special case code for each
number of possible dimensions, how can that be done? If one
supplies to the index a tuple, the tuple will be interpreted
as a list of indices. For example (using the previous definition
for the array z):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">40</span>
</pre></div>
</div>
<p>So one can use code to construct tuples of any number of indices
and then use these within an index.</p>
<p>Slices can be specified within programs by using the slice() function
in Python. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># same as [1,1,1,0:2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([39, 40])</span>
</pre></div>
</div>
<p>Likewise, ellipsis can be specified by code by using the Ellipsis
object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># same as [1,...,1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([[28, 31, 34],</span>
<span class="go">       [37, 40, 43],</span>
<span class="go">       [46, 49, 52]])</span>
</pre></div>
</div>
<p>For this reason it is possible to use the output from the np.nonzero()
function directly as an index since it always returns a tuple of index
arrays.</p>
<p>Because the special treatment of tuples, they are not automatically
converted to an array as a list would be. As an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="c1"># produces a large array</span>
<span class="go">array([[[[27, 28, 29],</span>
<span class="go">         [30, 31, 32], ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># returns a single value</span>
<span class="go">40</span>
</pre></div>
</div>
</div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="basics.creation.html" title="previous page">Array creation</a>
    <a class='right-next' id="next-link" href="basics.io.html" title="next page">I/O with NumPy</a>

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../_static/js/index.1e043a052b0af929e4d8.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2008-2021, The NumPy community.<br/>
        Last updated on Jun 22, 2021.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>