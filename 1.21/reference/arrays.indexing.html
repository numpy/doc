
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Indexing &#8212; NumPy v1.21 Manual</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.f6b7ca918bee2f46fd9abac01cfb07d5.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1e043a052b0af929e4d8.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Iterating Over Arrays" href="arrays.nditer.html" />
    <link rel="prev" title="numpy.dtype.__setstate__" href="generated/numpy.dtype.__setstate__.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
<link rel="stylesheet" href="../_static/numpy.css" type="text/css" />

    <!-- PR #17220: This is added via javascript in versionwarning.js  -->
    <!-- link rel="canonical" href="http://numpy.org/doc/stable/reference/arrays.indexing.html" / -->


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">


    
      
      <a class="navbar-brand" href="../index.html">
        <img src="../_static/numpylogo.svg" class="logo" alt="logo">
      </a>      
      
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    
    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../user/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dev/index.html">
  Development
 </a>
</li>

        
      </ul>

      <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/numpy/numpy" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/numpy_team" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l2 current active">
  <a class="reference internal" href="arrays.html">
   Array objects
  </a>
  <ul class="current">
   <li class="toctree-l3">
    <a class="reference internal" href="arrays.ndarray.html">
     The N-dimensional array (
     <code class="xref py py-class docutils literal notranslate">
      <span class="pre">
       ndarray
      </span>
     </code>
     )
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="arrays.scalars.html">
     Scalars
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="arrays.dtypes.html">
     Data type objects (
     <code class="xref py py-class docutils literal notranslate">
      <span class="pre">
       dtype
      </span>
     </code>
     )
    </a>
   </li>
   <li class="toctree-l3 current active">
    <a class="current reference internal" href="#">
     Indexing
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="arrays.nditer.html">
     Iterating Over Arrays
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="arrays.classes.html">
     Standard array subclasses
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="maskedarray.html">
     Masked arrays
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="arrays.interface.html">
     The Array Interface
    </a>
   </li>
   <li class="toctree-l3">
    <a class="reference internal" href="arrays.datetime.html">
     Datetimes and Timedeltas
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="constants.html">
   Constants
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="ufuncs.html">
   Universal functions (
   <code class="xref py py-class docutils literal notranslate">
    <span class="pre">
     ufunc
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="routines.html">
   Routines
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="typing.html">
   Typing (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     numpy.typing
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="global_state.html">
   Global State
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="distutils.html">
   Packaging (
   <code class="xref py py-mod docutils literal notranslate">
    <span class="pre">
     numpy.distutils
    </span>
   </code>
   )
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="distutils_guide.html">
   NumPy Distutils - Users Guide
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="c-api/index.html">
   NumPy C-API
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="internals.html">
   NumPy internals
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="simd/simd-optimizations.html">
   SIMD Optimizations
  </a>
 </li>
 <li class="toctree-l2">
  <a class="reference internal" href="swig.html">
   NumPy and SWIG
  </a>
 </li>
</ul>
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#basic-slicing-and-indexing">
   Basic Slicing and Indexing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#advanced-indexing">
   Advanced Indexing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#integer-array-indexing">
     Integer array indexing
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#purely-integer-array-indexing">
       Purely integer array indexing
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#combining-advanced-and-basic-indexing">
       Combining advanced and basic indexing
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#boolean-array-indexing">
     Boolean array indexing
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#detailed-notes">
   Detailed notes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#field-access">
   Field Access
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#flat-iterator-indexing">
   Flat Iterator indexing
  </a>
 </li>
</ul>

</nav>


              
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="indexing">
<span id="arrays-indexing"></span><h1>Indexing<a class="headerlink" href="#indexing" title="Permalink to this headline">¶</a></h1>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../user/basics.indexing.html#basics-indexing"><span class="std std-ref">Indexing basics</span></a></p>
</div>
<p id="index-0"><a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code></a> can be indexed using the standard Python
<code class="docutils literal notranslate"><span class="pre">x[obj]</span></code> syntax, where <em>x</em> is the array and <em>obj</em> the selection.
There are three kinds of indexing available: field access, basic
slicing, advanced indexing. Which one occurs depends on <em>obj</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In Python, <code class="docutils literal notranslate"><span class="pre">x[(exp1,</span> <span class="pre">exp2,</span> <span class="pre">...,</span> <span class="pre">expN)]</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">x[exp1,</span> <span class="pre">exp2,</span> <span class="pre">...,</span> <span class="pre">expN]</span></code>; the latter is just syntactic sugar
for the former.</p>
</div>
<div class="section" id="basic-slicing-and-indexing">
<h2>Basic Slicing and Indexing<a class="headerlink" href="#basic-slicing-and-indexing" title="Permalink to this headline">¶</a></h2>
<p>Basic slicing extends Python’s basic concept of slicing to N
dimensions. Basic slicing occurs when <em>obj</em> is a <a class="reference external" href="https://docs.python.org/dev/library/functions.html#slice" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> object
(constructed by <code class="docutils literal notranslate"><span class="pre">start:stop:step</span></code> notation inside of brackets), an
integer, or a tuple of slice objects and integers. <a class="reference external" href="https://docs.python.org/dev/library/constants.html#Ellipsis" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Ellipsis</span></code></a>
and <a class="reference internal" href="constants.html#numpy.newaxis" title="numpy.newaxis"><code class="xref py py-const docutils literal notranslate"><span class="pre">newaxis</span></code></a> objects can be interspersed with these as
well.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 1.15.0: </span>In order to remain backward compatible with a common usage in
Numeric, basic slicing is also initiated if the selection object is
any non-ndarray and non-tuple sequence (such as a <a class="reference external" href="https://docs.python.org/dev/library/stdtypes.html#list" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) containing
<a class="reference external" href="https://docs.python.org/dev/library/functions.html#slice" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> objects, the <a class="reference external" href="https://docs.python.org/dev/library/constants.html#Ellipsis" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> object, or the <a class="reference internal" href="constants.html#numpy.newaxis" title="numpy.newaxis"><code class="xref py py-const docutils literal notranslate"><span class="pre">newaxis</span></code></a>
object, but not for integer arrays or other embedded sequences.</p>
</div>
<p id="index-1">The simplest case of indexing with <em>N</em> integers returns an <a class="reference internal" href="arrays.scalars.html#arrays-scalars"><span class="std std-ref">array
scalar</span></a> representing the corresponding item.  As in
Python, all indices are zero-based: for the <em>i</em>-th index <span class="math notranslate nohighlight">\(n_i\)</span>,
the valid range is <span class="math notranslate nohighlight">\(0 \le n_i &lt; d_i\)</span> where <span class="math notranslate nohighlight">\(d_i\)</span> is the
<em>i</em>-th element of the shape of the array.  Negative indices are
interpreted as counting from the end of the array (<em>i.e.</em>, if
<span class="math notranslate nohighlight">\(n_i &lt; 0\)</span>, it means <span class="math notranslate nohighlight">\(n_i + d_i\)</span>).</p>
<p>All arrays generated by basic slicing are always <a class="reference internal" href="../glossary.html#term-view"><span class="xref std std-term">views</span></a>
of the original array.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NumPy slicing creates a <a class="reference internal" href="../glossary.html#term-view"><span class="xref std std-term">view</span></a> instead of a copy as in the case of
builtin Python sequences such as string, tuple and list.
Care must be taken when extracting
a small portion from a large array which becomes useless after the
extraction, because the small portion extracted contains a reference
to the large original array whose memory will not be released until
all arrays derived from it are garbage-collected. In such cases an
explicit <code class="docutils literal notranslate"><span class="pre">copy()</span></code> is recommended.</p>
</div>
<p>The standard rules of sequence slicing apply to basic slicing on a
per-dimension basis (including using a step index). Some useful
concepts to remember include:</p>
<ul>
<li><p>The basic slice syntax is <code class="docutils literal notranslate"><span class="pre">i:j:k</span></code> where <em>i</em> is the starting index,
<em>j</em> is the stopping index, and <em>k</em> is the step (<span class="math notranslate nohighlight">\(k\neq0\)</span>).
This selects the <em>m</em> elements (in the corresponding dimension) with
index values <em>i</em>, <em>i + k</em>, …, <em>i + (m - 1) k</em> where
<span class="math notranslate nohighlight">\(m = q + (r\neq0)\)</span> and <em>q</em> and <em>r</em> are the quotient and remainder
obtained by dividing <em>j - i</em> by <em>k</em>: <em>j - i = q k + r</em>, so that
<em>i + (m - 1) k &lt; j</em>.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([1, 3, 5])</span>
</pre></div>
</div>
</div>
</li>
<li><p>Negative <em>i</em> and <em>j</em> are interpreted as <em>n + i</em> and <em>n + j</em> where
<em>n</em> is the number of elements in the corresponding dimension.
Negative <em>k</em> makes stepping go towards smaller indices.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">array([8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([7, 6, 5, 4])</span>
</pre></div>
</div>
</div>
</li>
<li><p>Assume <em>n</em> is the number of elements in the dimension being
sliced. Then, if <em>i</em> is not given it defaults to 0 for <em>k &gt; 0</em> and
<em>n - 1</em> for <em>k &lt; 0</em> . If <em>j</em> is not given it defaults to <em>n</em> for <em>k &gt; 0</em>
and <em>-n-1</em> for <em>k &lt; 0</em> . If <em>k</em> is not given it defaults to 1. Note that
<code class="docutils literal notranslate"><span class="pre">::</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">:</span></code> and means select all indices along this
axis.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
<span class="go">array([5, 6, 7, 8, 9])</span>
</pre></div>
</div>
</div>
</li>
<li><p>If the number of objects in the selection tuple is less than
<em>N</em>, then <code class="docutils literal notranslate"><span class="pre">:</span></code> is assumed for any subsequent dimensions.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">array([[[4],</span>
<span class="go">        [5],</span>
<span class="go">        [6]]])</span>
</pre></div>
</div>
</div>
</li>
<li><p><a class="reference external" href="https://docs.python.org/dev/library/constants.html#Ellipsis" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> expands to the number of <code class="docutils literal notranslate"><span class="pre">:</span></code> objects needed for the
selection tuple to index all dimensions. In most cases, this means that
length of the expanded selection tuple is <code class="docutils literal notranslate"><span class="pre">x.ndim</span></code>. There may only be a
single ellipsis present.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
</div>
</li>
<li><p>Each <a class="reference internal" href="constants.html#numpy.newaxis" title="numpy.newaxis"><code class="xref py py-const docutils literal notranslate"><span class="pre">newaxis</span></code></a> object in the selection tuple serves to expand
the dimensions of the resulting selection by one unit-length
dimension.  The added dimension is the position of the <a class="reference internal" href="constants.html#numpy.newaxis" title="numpy.newaxis"><code class="xref py py-const docutils literal notranslate"><span class="pre">newaxis</span></code></a>
object in the selection tuple.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3, 1)</span>
</pre></div>
</div>
</div>
</li>
<li><p>An integer, <em>i</em>, returns the same values as <code class="docutils literal notranslate"><span class="pre">i:i+1</span></code>
<strong>except</strong> the dimensionality of the returned object is reduced by
1. In particular, a selection tuple with the <em>p</em>-th
element an integer (and all other entries <code class="docutils literal notranslate"><span class="pre">:</span></code>) returns the
corresponding sub-array with dimension <em>N - 1</em>. If <em>N = 1</em>
then the returned object is an array scalar. These objects are
explained in <a class="reference internal" href="arrays.scalars.html#arrays-scalars"><span class="std std-ref">Scalars</span></a>.</p></li>
<li><p>If the selection tuple has all entries <code class="docutils literal notranslate"><span class="pre">:</span></code> except the
<em>p</em>-th entry which is a slice object <code class="docutils literal notranslate"><span class="pre">i:j:k</span></code>,
then the returned array has dimension <em>N</em> formed by
concatenating the sub-arrays returned by integer indexing of
elements <em>i</em>, <em>i+k</em>, …, <em>i + (m - 1) k &lt; j</em>,</p></li>
<li><p>Basic slicing with more than one non-<code class="docutils literal notranslate"><span class="pre">:</span></code> entry in the slicing
tuple, acts like repeated application of slicing using a single
non-<code class="docutils literal notranslate"><span class="pre">:</span></code> entry, where the non-<code class="docutils literal notranslate"><span class="pre">:</span></code> entries are successively taken
(with all other non-<code class="docutils literal notranslate"><span class="pre">:</span></code> entries replaced by <code class="docutils literal notranslate"><span class="pre">:</span></code>). Thus,
<code class="docutils literal notranslate"><span class="pre">x[ind1,...,ind2,:]</span></code> acts like <code class="docutils literal notranslate"><span class="pre">x[ind1][...,ind2,:]</span></code> under basic
slicing.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The above is <strong>not</strong> true for advanced indexing.</p>
</div>
</li>
<li><p>You may use slicing to set values in the array, but (unlike lists) you
can never grow the array. The size of the value to be set in
<code class="docutils literal notranslate"><span class="pre">x[obj]</span> <span class="pre">=</span> <span class="pre">value</span></code> must be (broadcastable) to the same shape as
<code class="docutils literal notranslate"><span class="pre">x[obj]</span></code>.</p></li>
</ul>
<div class="admonition note" id="index-2">
<p class="admonition-title">Note</p>
<p>Remember that a slicing tuple can always be constructed as <em>obj</em>
and used in the <code class="docutils literal notranslate"><span class="pre">x[obj]</span></code> notation. Slice objects can be used in
the construction in place of the <code class="docutils literal notranslate"><span class="pre">[start:stop:step]</span></code>
notation. For example, <code class="docutils literal notranslate"><span class="pre">x[1:10:5,::-1]</span></code> can also be implemented
as <code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">=</span> <span class="pre">(slice(1,10,5),</span> <span class="pre">slice(None,None,-1));</span> <span class="pre">x[obj]</span></code> . This
can be useful for constructing generic code that works on arrays
of arbitrary dimension.</p>
</div>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">numpy.</span></span><span class="sig-name descname"><span class="pre">newaxis</span></span></dt>
<dd><p>The <a class="reference internal" href="constants.html#numpy.newaxis" title="numpy.newaxis"><code class="xref py py-const docutils literal notranslate"><span class="pre">newaxis</span></code></a> object can be used in all slicing operations to
create an axis of length one. <a class="reference internal" href="constants.html#numpy.newaxis" title="numpy.newaxis"><code class="xref py py-const docutils literal notranslate"><span class="pre">newaxis</span></code></a> is an alias for
‘None’, and ‘None’ can be used in place of this with the same result.</p>
</dd></dl>

</div>
<div class="section" id="advanced-indexing">
<span id="id1"></span><h2>Advanced Indexing<a class="headerlink" href="#advanced-indexing" title="Permalink to this headline">¶</a></h2>
<p>Advanced indexing is triggered when the selection object, <em>obj</em>, is a
non-tuple sequence object, an <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> (of data type integer or bool),
or a tuple with at least one sequence object or ndarray (of data type
integer or bool). There are two types of advanced indexing: integer
and Boolean.</p>
<p>Advanced indexing always returns a <em>copy</em> of the data (contrast with
basic slicing that returns a <a class="reference internal" href="../glossary.html#term-view"><span class="xref std std-term">view</span></a>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The definition of advanced indexing means that <code class="docutils literal notranslate"><span class="pre">x[(1,2,3),]</span></code> is
fundamentally different than <code class="docutils literal notranslate"><span class="pre">x[(1,2,3)]</span></code>. The latter is
equivalent to <code class="docutils literal notranslate"><span class="pre">x[1,2,3]</span></code> which will trigger basic selection while
the former will trigger advanced indexing. Be sure to understand
why this occurs.</p>
<p>Also recognize that <code class="docutils literal notranslate"><span class="pre">x[[1,2,3]]</span></code> will trigger advanced indexing,
whereas due to the deprecated Numeric compatibility mentioned above,
<code class="docutils literal notranslate"><span class="pre">x[[1,2,slice(None)]]</span></code> will trigger basic slicing.</p>
</div>
<div class="section" id="integer-array-indexing">
<h3>Integer array indexing<a class="headerlink" href="#integer-array-indexing" title="Permalink to this headline">¶</a></h3>
<p>Integer array indexing allows selection of arbitrary items in the array
based on their <em>N</em>-dimensional index. Each integer array represents a number
of indexes into that dimension.</p>
<div class="section" id="purely-integer-array-indexing">
<h4>Purely integer array indexing<a class="headerlink" href="#purely-integer-array-indexing" title="Permalink to this headline">¶</a></h4>
<p>When the index consists of as many integer arrays as the array being indexed
has dimensions, the indexing is straight forward, but different from slicing.</p>
<p>Advanced indexes always are <a class="reference internal" href="ufuncs.html#ufuncs-broadcasting"><span class="std std-ref">broadcast</span></a> and
iterated as <em>one</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_M</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">ind_1</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_M</span><span class="p">],</span> <span class="n">ind_2</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_M</span><span class="p">],</span>
                           <span class="o">...</span><span class="p">,</span> <span class="n">ind_N</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_M</span><span class="p">]]</span>
</pre></div>
</div>
<p>Note that the result shape is identical to the (broadcast) indexing array
shapes <code class="docutils literal notranslate"><span class="pre">ind_1,</span> <span class="pre">...,</span> <span class="pre">ind_N</span></code>.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>From each row, a specific element should be selected. The row index is just
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></code> and the column index specifies the element to choose for the
corresponding row, here <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></code>. Using both together the task
can be solved using advanced indexing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="go">array([1, 4, 5])</span>
</pre></div>
</div>
</div>
<p>To achieve a behaviour similar to the basic slicing above, broadcasting can be
used. The function <a class="reference internal" href="generated/numpy.ix_.html#numpy.ix_" title="numpy.ix_"><code class="xref py py-func docutils literal notranslate"><span class="pre">ix_</span></code></a> can help with this broadcasting. This is best
understood with an example.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>From a 4x3 array the corner elements should be selected using advanced
indexing. Thus all elements for which the column is one of <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">2]</span></code> and
the row is one of <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">3]</span></code> need to be selected. To use advanced indexing
one needs to select all elements <em>explicitly</em>. Using the method explained
previously one could write:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                 <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
<p>However, since the indexing arrays above just repeat themselves,
broadcasting can be used (compare operations such as
<code class="docutils literal notranslate"><span class="pre">rows[:,</span> <span class="pre">np.newaxis]</span> <span class="pre">+</span> <span class="pre">columns</span></code>) to simplify this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="go">array([[0],</span>
<span class="go">       [3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
<p>This broadcasting can also be achieved using the function <a class="reference internal" href="generated/numpy.ix_.html#numpy.ix_" title="numpy.ix_"><code class="xref py py-func docutils literal notranslate"><span class="pre">ix_</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">)]</span>
<span class="go">array([[ 0,  2],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
<p>Note that without the <code class="docutils literal notranslate"><span class="pre">np.ix_</span></code> call, only the diagonal elements would
be selected, as was used in the previous example. This difference is the
most important thing to remember about indexing with multiple advanced
indexes.</p>
</div>
</div>
<div class="section" id="combining-advanced-and-basic-indexing">
<span id="id2"></span><h4>Combining advanced and basic indexing<a class="headerlink" href="#combining-advanced-and-basic-indexing" title="Permalink to this headline">¶</a></h4>
<p>When there is at least one slice (<code class="docutils literal notranslate"><span class="pre">:</span></code>), ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>) or <a class="reference internal" href="constants.html#numpy.newaxis" title="numpy.newaxis"><code class="xref py py-const docutils literal notranslate"><span class="pre">newaxis</span></code></a>
in the index (or the array has more dimensions than there are advanced indexes),
then the behaviour can be more complicated. It is like concatenating the
indexing result for each advanced index element</p>
<p>In the simplest case, there is only a <em>single</em> advanced index. A single
advanced index can for example replace a slice and the result array will be
the same, however, it is a copy and may have a different memory layout.
A slice is preferable when it is possible.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">array([[4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="go">array([[4, 5]])</span>
</pre></div>
</div>
</div>
<p>The easiest way to understand the situation may be to think in
terms of the result shape. There are two parts to the indexing operation,
the subspace defined by the basic indexing (excluding integers) and the
subspace from the advanced indexing part. Two cases of index combination
need to be distinguished:</p>
<ul class="simple">
<li><p>The advanced indexes are separated by a slice, <a class="reference external" href="https://docs.python.org/dev/library/constants.html#Ellipsis" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> or <a class="reference internal" href="constants.html#numpy.newaxis" title="numpy.newaxis"><code class="xref py py-const docutils literal notranslate"><span class="pre">newaxis</span></code></a>.
For example <code class="docutils literal notranslate"><span class="pre">x[arr1,</span> <span class="pre">:,</span> <span class="pre">arr2]</span></code>.</p></li>
<li><p>The advanced indexes are all next to each other.
For example <code class="docutils literal notranslate"><span class="pre">x[...,</span> <span class="pre">arr1,</span> <span class="pre">arr2,</span> <span class="pre">:]</span></code> but <em>not</em> <code class="docutils literal notranslate"><span class="pre">x[arr1,</span> <span class="pre">:,</span> <span class="pre">1]</span></code>
since <code class="docutils literal notranslate"><span class="pre">1</span></code> is an advanced index in this regard.</p></li>
</ul>
<p>In the first case, the dimensions resulting from the advanced indexing
operation come first in the result array, and the subspace dimensions after
that.
In the second case, the dimensions from the advanced indexing operations
are inserted into the result array at the same spot as they were in the
initial array (the latter logic is what makes simple advanced indexing
behave just like slicing).</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>Suppose <code class="docutils literal notranslate"><span class="pre">x.shape</span></code> is (10,20,30) and <code class="docutils literal notranslate"><span class="pre">ind</span></code> is a (2,3,4)-shaped
indexing <a class="reference internal" href="arrays.scalars.html#numpy.intp" title="numpy.intp"><code class="xref py py-class docutils literal notranslate"><span class="pre">intp</span></code></a> array, then <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">x[...,ind,:]</span></code> has
shape (10,2,3,4,30) because the (20,)-shaped subspace has been
replaced with a (2,3,4)-shaped broadcasted indexing subspace. If
we let <em>i, j, k</em> loop over the (2,3,4)-shaped subspace then
<code class="docutils literal notranslate"><span class="pre">result[...,i,j,k,:]</span> <span class="pre">=</span> <span class="pre">x[...,ind[i,j,k],:]</span></code>. This example
produces the same result as <a class="reference internal" href="generated/numpy.ndarray.take.html#numpy.ndarray.take" title="numpy.ndarray.take"><code class="xref py py-meth docutils literal notranslate"><span class="pre">x.take(ind,</span> <span class="pre">axis=-2)</span></code></a>.</p>
</div>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">x.shape</span></code> be (10,20,30,40,50) and suppose <code class="docutils literal notranslate"><span class="pre">ind_1</span></code>
and <code class="docutils literal notranslate"><span class="pre">ind_2</span></code> can be broadcast to the shape (2,3,4).  Then
<code class="docutils literal notranslate"><span class="pre">x[:,ind_1,ind_2]</span></code> has shape (10,2,3,4,40,50) because the
(20,30)-shaped subspace from X has been replaced with the
(2,3,4) subspace from the indices.  However,
<code class="docutils literal notranslate"><span class="pre">x[:,ind_1,:,ind_2]</span></code> has shape (2,3,4,10,30,50) because there
is no unambiguous place to drop in the indexing subspace, thus
it is tacked-on to the beginning. It is always possible to use
<a class="reference internal" href="generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose" title="numpy.ndarray.transpose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">.transpose()</span></code></a> to move the subspace
anywhere desired. Note that this example cannot be replicated
using <a class="reference internal" href="generated/numpy.take.html#numpy.take" title="numpy.take"><code class="xref py py-func docutils literal notranslate"><span class="pre">take</span></code></a>.</p>
</div>
</div>
</div>
<div class="section" id="boolean-array-indexing">
<h3>Boolean array indexing<a class="headerlink" href="#boolean-array-indexing" title="Permalink to this headline">¶</a></h3>
<p>This advanced indexing occurs when obj is an array object of Boolean
type, such as may be returned from comparison operators. A single
boolean index array is practically identical to <code class="docutils literal notranslate"><span class="pre">x[obj.nonzero()]</span></code> where,
as described above, <a class="reference internal" href="generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero" title="numpy.ndarray.nonzero"><code class="xref py py-meth docutils literal notranslate"><span class="pre">obj.nonzero()</span></code></a> returns a
tuple (of length <a class="reference internal" href="generated/numpy.ndarray.ndim.html#numpy.ndarray.ndim" title="numpy.ndarray.ndim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obj.ndim</span></code></a>) of integer index
arrays showing the <a class="reference external" href="https://docs.python.org/dev/library/constants.html#True" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a> elements of <em>obj</em>. However, it is
faster when <code class="docutils literal notranslate"><span class="pre">obj.shape</span> <span class="pre">==</span> <span class="pre">x.shape</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">obj.ndim</span> <span class="pre">==</span> <span class="pre">x.ndim</span></code>, <code class="docutils literal notranslate"><span class="pre">x[obj]</span></code> returns a 1-dimensional array
filled with the elements of <em>x</em> corresponding to the <a class="reference external" href="https://docs.python.org/dev/library/constants.html#True" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a>
values of <em>obj</em>.  The search order will be <a class="reference internal" href="../glossary.html#term-row-major"><span class="xref std std-term">row-major</span></a>,
C-style. If <em>obj</em> has <a class="reference external" href="https://docs.python.org/dev/library/constants.html#True" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a> values at entries that are outside
of the bounds of <em>x</em>, then an index error will be raised. If <em>obj</em> is
smaller than <em>x</em> it is identical to filling it with <a class="reference external" href="https://docs.python.org/dev/library/constants.html#False" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a>.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>A common use case for this is filtering for desired element values.
For example one may wish to select all entries from an array which
are not NaN:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([1., 2., 3.])</span>
</pre></div>
</div>
<p>Or wish to add a constant to all negative elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([  1.,  19.,  18.,   3.])</span>
</pre></div>
</div>
</div>
<p>In general if an index includes a Boolean array, the result will be
identical to inserting <code class="docutils literal notranslate"><span class="pre">obj.nonzero()</span></code> into the same position
and using the integer array indexing mechanism described above.
<code class="docutils literal notranslate"><span class="pre">x[ind_1,</span> <span class="pre">boolean_array,</span> <span class="pre">ind_2]</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">x[(ind_1,)</span> <span class="pre">+</span> <span class="pre">boolean_array.nonzero()</span> <span class="pre">+</span> <span class="pre">(ind_2,)]</span></code>.</p>
<p>If there is only one Boolean array and no integer indexing array present,
this is straight forward. Care must only be taken to make sure that the
boolean index has <em>exactly</em> as many dimensions as it is supposed to work
with.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>From an array, select all rows which sum up to less or equal two:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rowsum</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rowsum</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 1]])</span>
</pre></div>
</div>
</div>
<p>Combining multiple Boolean indexing arrays or a Boolean with an integer
indexing array can best be understood with the
<a class="reference internal" href="generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero" title="numpy.ndarray.nonzero"><code class="xref py py-meth docutils literal notranslate"><span class="pre">obj.nonzero()</span></code></a> analogy. The function <a class="reference internal" href="generated/numpy.ix_.html#numpy.ix_" title="numpy.ix_"><code class="xref py py-func docutils literal notranslate"><span class="pre">ix_</span></code></a>
also supports boolean arrays and will work without any surprises.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<p>Use boolean indexing to select all rows adding up to an even
number. At the same time columns 0 and 2 should be selected with an
advanced integer index. Using the <a class="reference internal" href="generated/numpy.ix_.html#numpy.ix_" title="numpy.ix_"><code class="xref py py-func docutils literal notranslate"><span class="pre">ix_</span></code></a> function this can be done
with:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span>
<span class="go">array([False,  True, False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">)]</span>
<span class="go">array([[ 3,  5],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">np.ix_</span></code> call, only the diagonal elements would be
selected.</p>
<p>Or without <code class="docutils literal notranslate"><span class="pre">np.ix_</span></code> (compare the integer array examples):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">columns</span><span class="p">]</span>
<span class="go">array([[ 3,  5],</span>
<span class="go">       [ 9, 11]])</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="detailed-notes">
<h2>Detailed notes<a class="headerlink" href="#detailed-notes" title="Permalink to this headline">¶</a></h2>
<p>These are some detailed notes, which are not of importance for day to day
indexing (in no particular order):</p>
<ul class="simple">
<li><p>The native NumPy indexing type is <code class="docutils literal notranslate"><span class="pre">intp</span></code> and may differ from the
default integer array type. <code class="docutils literal notranslate"><span class="pre">intp</span></code> is the smallest data type
sufficient to safely index any array; for advanced indexing it may be
faster than other types.</p></li>
<li><p>For advanced assignments, there is in general no guarantee for the
iteration order. This means that if an element is set more than once,
it is not possible to predict the final result.</p></li>
<li><p>An empty (tuple) index is a full scalar index into a zero dimensional array.
<code class="docutils literal notranslate"><span class="pre">x[()]</span></code> returns a <em>scalar</em> if <code class="docutils literal notranslate"><span class="pre">x</span></code> is zero dimensional and a view
otherwise. On the other hand <code class="docutils literal notranslate"><span class="pre">x[...]</span></code> always returns a view.</p></li>
<li><p>If a zero dimensional array is present in the index <em>and</em> it is a full
integer index the result will be a <em>scalar</em> and not a zero dimensional array.
(Advanced indexing is not triggered.)</p></li>
<li><p>When an ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>) is present but has no size (i.e. replaces zero
<code class="docutils literal notranslate"><span class="pre">:</span></code>) the result will still always be an array. A view if no advanced index
is present, otherwise a copy.</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">nonzero</span></code> equivalence for Boolean arrays does not hold for zero
dimensional boolean arrays.</p></li>
<li><p>When the result of an advanced indexing operation has no elements but an
individual index is out of bounds, whether or not an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> is
raised is undefined (e.g. <code class="docutils literal notranslate"><span class="pre">x[[],</span> <span class="pre">[123]]</span></code> with <code class="docutils literal notranslate"><span class="pre">123</span></code> being out of bounds).</p></li>
<li><p>When a <em>casting</em> error occurs during assignment (for example updating a
numerical array using a sequence of strings), the array being assigned
to may end up in an unpredictable partially updated state.
However, if any other error (such as an out of bounds index) occurs, the
array will remain unchanged.</p></li>
<li><p>The memory layout of an advanced indexing result is optimized for each
indexing operation and no particular memory order can be assumed.</p></li>
<li><p>When using a subclass (especially one which manipulates its shape), the
default <code class="docutils literal notranslate"><span class="pre">ndarray.__setitem__</span></code> behaviour will call <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> for
<em>basic</em> indexing but not for <em>advanced</em> indexing. For such a subclass it may
be preferable to call <code class="docutils literal notranslate"><span class="pre">ndarray.__setitem__</span></code> with a <em>base class</em> ndarray
view on the data. This <em>must</em> be done if the subclasses <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> does
not return views.</p></li>
</ul>
</div>
<div class="section" id="field-access">
<span id="arrays-indexing-fields"></span><h2>Field Access<a class="headerlink" href="#field-access" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="arrays.dtypes.html#arrays-dtypes"><span class="std std-ref">Data type objects (dtype)</span></a>, <a class="reference internal" href="arrays.scalars.html#arrays-scalars"><span class="std std-ref">Scalars</span></a></p>
</div>
<p>If the <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> object is a structured array the <a class="reference internal" href="../glossary.html#term-field"><span class="xref std std-term">fields</span></a>
of the array can be accessed by indexing the array with strings,
dictionary-like.</p>
<p>Indexing <code class="docutils literal notranslate"><span class="pre">x['field-name']</span></code> returns a new <a class="reference internal" href="../glossary.html#term-view"><span class="xref std std-term">view</span></a> to the array,
which is of the same shape as <em>x</em> (except when the field is a
sub-array) but of data type <code class="docutils literal notranslate"><span class="pre">x.dtype['field-name']</span></code> and contains
only the part of the data in the specified field. Also
<a class="reference internal" href="arrays.classes.html#arrays-classes-rec"><span class="std std-ref">record array</span></a> scalars can be “indexed” this way.</p>
<p>Indexing into a structured array can also be done with a list of field names,
<em>e.g.</em> <code class="docutils literal notranslate"><span class="pre">x[['field-name1','field-name2']]</span></code>. As of NumPy 1.16 this returns a
view containing only those fields. In older versions of numpy it returned a
copy. See the user guide section on <a class="reference internal" href="../user/basics.rec.html#structured-arrays"><span class="std std-ref">Structured arrays</span></a> for more
information on multifield indexing.</p>
<p>If the accessed field is a sub-array, the dimensions of the sub-array
are appended to the shape of the result.</p>
<div class="admonition-example admonition">
<p class="admonition-title">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;int32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 3, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="flat-iterator-indexing">
<h2>Flat Iterator indexing<a class="headerlink" href="#flat-iterator-indexing" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="generated/numpy.ndarray.flat.html#numpy.ndarray.flat" title="numpy.ndarray.flat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x.flat</span></code></a> returns an iterator that will iterate
over the entire array (in C-contiguous style with the last index
varying the fastest). This iterator object can also be indexed using
basic slicing or advanced indexing as long as the selection object is
not a tuple. This should be clear from the fact that <a class="reference internal" href="generated/numpy.ndarray.flat.html#numpy.ndarray.flat" title="numpy.ndarray.flat"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x.flat</span></code></a> is a 1-dimensional view. It can be used for integer
indexing with 1-dimensional C-style-flat indices. The shape of any
returned array is therefore the shape of the integer indexing object.</p>
<span class="target" id="index-3"></span></div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="generated/numpy.dtype.__setstate__.html" title="previous page">numpy.dtype.__setstate__</a>
    <a class='right-next' id="next-link" href="arrays.nditer.html" title="next page">Iterating Over Arrays</a>

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../_static/js/index.1e043a052b0af929e4d8.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2008-2021, The NumPy community.<br/>
        Last updated on Jun 22, 2021.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>