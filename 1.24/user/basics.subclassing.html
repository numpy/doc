
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Subclassing ndarray &#8212; NumPy v1.24 Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/numpy.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Interoperability with NumPy" href="basics.interoperability.html" />
    <link rel="prev" title="Writing custom array containers" href="basics.dispatch.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="light">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../index.html">
  
  
  
  
    <img src="../_static/numpylogo.svg" class="logo__image only-light" alt="Logo image">
    <img src="../_static/numpylogo_dark.svg" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dev/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../release.html">
  Release notes
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://numpy.org/numpy-tutorials/">Learn<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        1.24  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables user/basics.subclassing and {'version_match': '1.24', 'json_url': 'https://numpy.org/doc/_static/versions.json'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "user/basics.subclassing.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://numpy.org/doc/_static/versions.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "user/basics.subclassing.html";
        let btn = document.getElementById("version_switcher_button");
        // Set empty strings by default so that these attributes exist and can be used in CSS selectors
        btn.dataset["activeVersionName"] = "";
        btn.dataset["activeVersion"] = "";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 1.24 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "1.24") {
                node.classList.add("active");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/numpy/numpy" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/numpy_team" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="whatisnumpy.html">
   What is NumPy?
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://numpy.org/install/">
   Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="quickstart.html">
   NumPy quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="absolute_beginners.html">
   NumPy: the absolute basics for beginners
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Fundamentals and usage
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basics.html">
   NumPy fundamentals
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="numpy-for-matlab-users.html">
   NumPy for MATLAB users
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://numpy.org/numpy-tutorials/features.html">
   NumPy Tutorials
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="howtos_index.html">
   NumPy How Tos
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced usage and interoperability
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="building.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="c-info.html">
   Using NumPy C-API
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../f2py/index.html">
   F2PY user guide and reference manual
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../dev/underthehood.html">
   Under-the-hood documentation for developers
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="../dev/internals.html">
     Internal organization of NumPy arrays
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../dev/internals.code-explanations.html">
     NumPy C code explanations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../dev/alignment.html">
     Memory Alignment
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="byteswapping.html">
     Byte-swapping
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="basics.dispatch.html">
     Writing custom array containers
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Subclassing ndarray
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="basics.interoperability.html">
   Interoperability with NumPy
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Extras
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../glossary.html">
   Glossary
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../release.html">
   Release notes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../license.html">
   NumPy license
  </a>
 </li>
</ul>

  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ndarrays-and-object-creation">
     ndarrays and object creation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#when-to-use-subclassing">
     When to use subclassing
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#view-casting">
   View casting
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#creating-new-from-template">
   Creating new from template
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#relationship-of-view-casting-and-new-from-template">
   Relationship of view casting and new-from-template
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#implications-for-subclassing">
   Implications for subclassing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-brief-python-primer-on-new-and-init">
     A brief Python primer on
     <code class="docutils literal notranslate">
      <span class="pre">
       __new__
      </span>
     </code>
     and
     <code class="docutils literal notranslate">
      <span class="pre">
       __init__
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-role-of-array-finalize">
     The role of
     <code class="docutils literal notranslate">
      <span class="pre">
       __array_finalize__
      </span>
     </code>
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simple-example-adding-an-extra-attribute-to-ndarray">
   Simple example - adding an extra attribute to ndarray
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#slightly-more-realistic-example-attribute-added-to-existing-array">
   Slightly more realistic example - attribute added to existing array
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-ufunc-for-ufuncs">
   <code class="docutils literal notranslate">
    <span class="pre">
     __array_ufunc__
    </span>
   </code>
   for ufuncs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#array-wrap-for-ufuncs-and-other-functions">
   <code class="docutils literal notranslate">
    <span class="pre">
     __array_wrap__
    </span>
   </code>
   for ufuncs and other functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#extra-gotchas-custom-del-methods-and-ndarray-base">
   Extra gotchas - custom
   <code class="docutils literal notranslate">
    <span class="pre">
     __del__
    </span>
   </code>
   methods and ndarray.base
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#subclassing-and-downstream-compatibility">
   Subclassing and Downstream Compatibility
  </a>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="subclassing-ndarray">
<span id="basics-subclassing"></span><h1>Subclassing ndarray<a class="headerlink" href="#subclassing-ndarray" title="Permalink to this heading">#</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h2>
<p>Subclassing ndarray is relatively simple, but it has some complications
compared to other Python objects.  On this page we explain the machinery
that allows you to subclass ndarray, and the implications for
implementing a subclass.</p>
<section id="ndarrays-and-object-creation">
<h3>ndarrays and object creation<a class="headerlink" href="#ndarrays-and-object-creation" title="Permalink to this heading">#</a></h3>
<p>Subclassing ndarray is complicated by the fact that new instances of
ndarray classes can come about in three different ways.  These are:</p>
<ol class="arabic simple">
<li><p>Explicit constructor call - as in <code class="docutils literal notranslate"><span class="pre">MySubClass(params)</span></code>.  This is
the usual route to Python instance creation.</p></li>
<li><p>View casting - casting an existing ndarray as a given subclass</p></li>
<li><p>New from template - creating a new instance from a template
instance. Examples include returning slices from a subclassed array,
creating return types from ufuncs, and copying arrays.  See
<a class="reference internal" href="#new-from-template"><span class="std std-ref">Creating new from template</span></a> for more details</p></li>
</ol>
<p>The last two are characteristics of ndarrays - in order to support
things like array slicing.  The complications of subclassing ndarray are
due to the mechanisms numpy has to support these latter two routes of
instance creation.</p>
</section>
<section id="when-to-use-subclassing">
<h3>When to use subclassing<a class="headerlink" href="#when-to-use-subclassing" title="Permalink to this heading">#</a></h3>
<p>Besides the additional complexities of subclassing a NumPy array, subclasses
can run into unexpected behaviour because some functions may convert the
subclass to a baseclass and “forget” any additional information
associated with the subclass.
This can result in surprising behavior if you use NumPy methods or
functions you have not explicitly tested.</p>
<p>On the other hand, compared to other interoperability approaches,
subclassing can be a useful because many thing will “just work”.</p>
<p>This means that subclassing can be a convenient approach and for a long time
it was also often the only available approach.
However, NumPy now provides additional interoperability protocols described
in “<a class="reference internal" href="basics.interoperability.html#basics-interoperability"><span class="std std-ref">Interoperability with NumPy</span></a>”.
For many use-cases these interoperability protocols may now be a better fit
or supplement the use of subclassing.</p>
<p>Subclassing can be a good fit if:</p>
<ul class="simple">
<li><p>you are less worried about maintainability or users other than yourself:
Subclass will be faster to implement and additional interoperability
can be added “as-needed”.  And with few users, possible surprises are not
an issue.</p></li>
<li><p>you do not think it is problematic if the subclass information is
ignored or lost silently.  An example is <code class="docutils literal notranslate"><span class="pre">np.memmap</span></code> where “forgetting”
about data being memory mapped cannot lead to a wrong result.
An example of a subclass that sometimes confuses users are NumPy’s masked
arrays.  When they were introduced, subclassing was the only approach for
implementation.  However, today we would possibly try to avoid subclassing
and rely only on interoperability protocols.</p></li>
</ul>
<p>Note that also subclass authors may wish to study
<a class="reference internal" href="basics.interoperability.html#basics-interoperability"><span class="std std-ref">Interoperability with NumPy</span></a>
to support more complex use-cases or work around the surprising behavior.</p>
<p><code class="docutils literal notranslate"><span class="pre">astropy.units.Quantity</span></code> and <code class="docutils literal notranslate"><span class="pre">xarray</span></code> are examples for array-like objects
that interoperate well with NumPy.  Astropy’s <code class="docutils literal notranslate"><span class="pre">Quantity</span></code> is an example
which uses a dual approach of both subclassing and interoperability protocols.</p>
</section>
</section>
<section id="view-casting">
<span id="id1"></span><h2>View casting<a class="headerlink" href="#view-casting" title="Permalink to this heading">#</a></h2>
<p><em>View casting</em> is the standard ndarray mechanism by which you take an
ndarray of any subclass, and return a view of the array as another
(specified) subclass:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create a completely useless ndarray subclass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># create a standard ndarray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># take a view of it, as our useless subclass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c_arr</span><span class="p">)</span>
<span class="go">&lt;class &#39;__main__.C&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="creating-new-from-template">
<span id="new-from-template"></span><h2>Creating new from template<a class="headerlink" href="#creating-new-from-template" title="Permalink to this heading">#</a></h2>
<p>New instances of an ndarray subclass can also come about by a very
similar mechanism to <a class="reference internal" href="#view-casting"><span class="std std-ref">View casting</span></a>, when numpy finds it needs to
create a new instance from a template instance.  The most obvious place
this has to happen is when you are taking slices of subclassed arrays.
For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">c_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="c1"># the view is of type &#39;C&#39;</span>
<span class="go">&lt;class &#39;__main__.C&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="ow">is</span> <span class="n">c_arr</span> <span class="c1"># but it&#39;s a new instance</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The slice is a <em>view</em> onto the original <code class="docutils literal notranslate"><span class="pre">c_arr</span></code> data.  So, when we
take a view from the ndarray, we return a new ndarray, of the same
class, that points to the data in the original.</p>
<p>There are other points in the use of ndarrays where we need such views,
such as copying arrays (<code class="docutils literal notranslate"><span class="pre">c_arr.copy()</span></code>), creating ufunc output arrays
(see also <a class="reference internal" href="#array-wrap"><span class="std std-ref">__array_wrap__ for ufuncs and other functions</span></a>), and reducing methods (like
<code class="docutils literal notranslate"><span class="pre">c_arr.mean()</span></code>).</p>
</section>
<section id="relationship-of-view-casting-and-new-from-template">
<h2>Relationship of view casting and new-from-template<a class="headerlink" href="#relationship-of-view-casting-and-new-from-template" title="Permalink to this heading">#</a></h2>
<p>These paths both use the same machinery.  We make the distinction here,
because they result in different input to your methods.  Specifically,
<a class="reference internal" href="#view-casting"><span class="std std-ref">View casting</span></a> means you have created a new instance of your array
type from any potential subclass of ndarray.  <a class="reference internal" href="#new-from-template"><span class="std std-ref">Creating new from template</span></a>
means you have created a new instance of your class from a pre-existing
instance, allowing you - for example - to copy across attributes that
are particular to your subclass.</p>
</section>
<section id="implications-for-subclassing">
<h2>Implications for subclassing<a class="headerlink" href="#implications-for-subclassing" title="Permalink to this heading">#</a></h2>
<p>If we subclass ndarray, we need to deal not only with explicit
construction of our array type, but also <a class="reference internal" href="#view-casting"><span class="std std-ref">View casting</span></a> or
<a class="reference internal" href="#new-from-template"><span class="std std-ref">Creating new from template</span></a>.  NumPy has the machinery to do this, and it is
this machinery that makes subclassing slightly non-standard.</p>
<p>There are two aspects to the machinery that ndarray uses to support
views and new-from-template in subclasses.</p>
<p>The first is the use of the <code class="docutils literal notranslate"><span class="pre">ndarray.__new__</span></code> method for the main work
of object initialization, rather then the more usual <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
method.  The second is the use of the <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> method to
allow subclasses to clean up after the creation of views and new
instances from templates.</p>
<section id="a-brief-python-primer-on-new-and-init">
<h3>A brief Python primer on <code class="docutils literal notranslate"><span class="pre">__new__</span></code> and <code class="docutils literal notranslate"><span class="pre">__init__</span></code><a class="headerlink" href="#a-brief-python-primer-on-new-and-init" title="Permalink to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__new__</span></code> is a standard Python method, and, if present, is called
before <code class="docutils literal notranslate"><span class="pre">__init__</span></code> when we create a class instance. See the <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__">python
__new__ documentation</a> for more detail.</p>
<p>For example, consider the following Python code:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cls in __new__:&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Args in __new__:&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="c1"># The `object` type __new__ method takes a single argument.</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;type(self) in __init__:&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Args in __init__:&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>meaning that we get:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">Cls in __new__: &lt;class &#39;C&#39;&gt;</span>
<span class="go">Args in __new__: (&#39;hello&#39;,)</span>
<span class="go">type(self) in __init__: &lt;class &#39;C&#39;&gt;</span>
<span class="go">Args in __init__: (&#39;hello&#39;,)</span>
</pre></div>
</div>
<p>When we call <code class="docutils literal notranslate"><span class="pre">C('hello')</span></code>, the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method gets its own class
as first argument, and the passed argument, which is the string
<code class="docutils literal notranslate"><span class="pre">'hello'</span></code>.  After python calls <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, it usually (see below)
calls our <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, with the output of <code class="docutils literal notranslate"><span class="pre">__new__</span></code> as the
first argument (now a class instance), and the passed arguments
following.</p>
<p>As you can see, the object can be initialized in the <code class="docutils literal notranslate"><span class="pre">__new__</span></code>
method or the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, or both, and in fact ndarray does
not have an <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, because all the initialization is
done in the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method.</p>
<p>Why use <code class="docutils literal notranslate"><span class="pre">__new__</span></code> rather than just the usual <code class="docutils literal notranslate"><span class="pre">__init__</span></code>?  Because
in some cases, as for ndarray, we want to be able to return an object
of some other class.  Consider the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;D cls is:&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;D args in __new__:&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># we never get here</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In D __init__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>meaning that:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">D cls is: &lt;class &#39;D&#39;&gt;</span>
<span class="go">D args in __new__: (&#39;hello&#39;,)</span>
<span class="go">Cls in __new__: &lt;class &#39;C&#39;&gt;</span>
<span class="go">Args in __new__: (&#39;hello&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="go">&lt;class &#39;C&#39;&gt;</span>
</pre></div>
</div>
<p>The definition of <code class="docutils literal notranslate"><span class="pre">C</span></code> is the same as before, but for <code class="docutils literal notranslate"><span class="pre">D</span></code>, the
<code class="docutils literal notranslate"><span class="pre">__new__</span></code> method returns an instance of class <code class="docutils literal notranslate"><span class="pre">C</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">D</span></code>.  Note that the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method of <code class="docutils literal notranslate"><span class="pre">D</span></code> does not get
called.  In general, when the <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method returns an object of
class other than the class in which it is defined, the <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
method of that class is not called.</p>
<p>This is how subclasses of the ndarray class are able to return views
that preserve the class type.  When taking a view, the standard
ndarray machinery creates the new ndarray object with something
like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">...</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">subdtype</span></code> is the subclass.  Thus the returned view is of the
same class as the subclass, rather than being of class <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.</p>
<p>That solves the problem of returning views of the same type, but now
we have a new problem.  The machinery of ndarray can set the class
this way, in its standard methods for taking views, but the ndarray
<code class="docutils literal notranslate"><span class="pre">__new__</span></code> method knows nothing of what we have done in our own
<code class="docutils literal notranslate"><span class="pre">__new__</span></code> method in order to set attributes, and so on.  (Aside -
why not call <code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">=</span> <span class="pre">subdtype.__new__(...</span></code> then?  Because we may not
have a <code class="docutils literal notranslate"><span class="pre">__new__</span></code> method with the same call signature).</p>
</section>
<section id="the-role-of-array-finalize">
<h3>The role of <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code><a class="headerlink" href="#the-role-of-array-finalize" title="Permalink to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> is the mechanism that numpy provides to allow
subclasses to handle the various ways that new instances get created.</p>
<p>Remember that subclass instances can come about in these three ways:</p>
<ol class="arabic simple">
<li><p>explicit constructor call (<code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">=</span> <span class="pre">MySubClass(params)</span></code>).  This will
call the usual sequence of <code class="docutils literal notranslate"><span class="pre">MySubClass.__new__</span></code> then (if it exists)
<code class="docutils literal notranslate"><span class="pre">MySubClass.__init__</span></code>.</p></li>
<li><p><a class="reference internal" href="#view-casting"><span class="std std-ref">View casting</span></a></p></li>
<li><p><a class="reference internal" href="#new-from-template"><span class="std std-ref">Creating new from template</span></a></p></li>
</ol>
<p>Our <code class="docutils literal notranslate"><span class="pre">MySubClass.__new__</span></code> method only gets called in the case of the
explicit constructor call, so we can’t rely on <code class="docutils literal notranslate"><span class="pre">MySubClass.__new__</span></code> or
<code class="docutils literal notranslate"><span class="pre">MySubClass.__init__</span></code> to deal with the view casting and
new-from-template.  It turns out that <code class="docutils literal notranslate"><span class="pre">MySubClass.__array_finalize__</span></code>
<em>does</em> get called for all three methods of object creation, so this is
where our object creation housekeeping usually goes.</p>
<ul class="simple">
<li><p>For the explicit constructor call, our subclass will need to create a
new ndarray instance of its own class.  In practice this means that
we, the authors of the code, will need to make a call to
<code class="docutils literal notranslate"><span class="pre">ndarray.__new__(MySubClass,...)</span></code>, a class-hierarchy prepared call to
<code class="docutils literal notranslate"><span class="pre">super().__new__(cls,</span> <span class="pre">...)</span></code>, or do view casting of an existing array
(see below)</p></li>
<li><p>For view casting and new-from-template, the equivalent of
<code class="docutils literal notranslate"><span class="pre">ndarray.__new__(MySubClass,...</span></code> is called, at the C level.</p></li>
</ul>
<p>The arguments that <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> receives differ for the three
methods of instance creation above.</p>
<p>The following code allows us to look at the call sequences and arguments:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In __new__ with class </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># in practice you probably will not need or want an __init__</span>
        <span class="c1"># method for your subclass</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In __init__ with class </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In array_finalize:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   self type is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   obj type is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</pre></div>
</div>
<p>Now:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Explicit constructor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">((</span><span class="mi">10</span><span class="p">,))</span>
<span class="go">In __new__ with class &lt;class &#39;C&#39;&gt;</span>
<span class="go">In array_finalize:</span>
<span class="go">   self type is &lt;class &#39;C&#39;&gt;</span>
<span class="go">   obj type is &lt;type &#39;NoneType&#39;&gt;</span>
<span class="go">In __init__ with class &lt;class &#39;C&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># View casting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">In array_finalize:</span>
<span class="go">   self type is &lt;class &#39;C&#39;&gt;</span>
<span class="go">   obj type is &lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Slicing (example of new-from-template)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cv</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
<span class="go">In array_finalize:</span>
<span class="go">   self type is &lt;class &#39;C&#39;&gt;</span>
<span class="go">   obj type is &lt;class &#39;C&#39;&gt;</span>
</pre></div>
</div>
<p>The signature of <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
</pre></div>
</div>
<p>One sees that the <code class="docutils literal notranslate"><span class="pre">super</span></code> call, which goes to
<code class="docutils literal notranslate"><span class="pre">ndarray.__new__</span></code>, passes <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> the new object, of our
own class (<code class="docutils literal notranslate"><span class="pre">self</span></code>) as well as the object from which the view has been
taken (<code class="docutils literal notranslate"><span class="pre">obj</span></code>).  As you can see from the output above, the <code class="docutils literal notranslate"><span class="pre">self</span></code> is
always a newly created instance of our subclass, and the type of <code class="docutils literal notranslate"><span class="pre">obj</span></code>
differs for the three instance creation methods:</p>
<ul class="simple">
<li><p>When called from the explicit constructor, <code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p>When called from view casting, <code class="docutils literal notranslate"><span class="pre">obj</span></code> can be an instance of any
subclass of ndarray, including our own.</p></li>
<li><p>When called in new-from-template, <code class="docutils literal notranslate"><span class="pre">obj</span></code> is another instance of our
own subclass, that we might use to update the new <code class="docutils literal notranslate"><span class="pre">self</span></code> instance.</p></li>
</ul>
<p>Because <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> is the only method that always sees new
instances being created, it is the sensible place to fill in instance
defaults for new object attributes, among other tasks.</p>
<p>This may be clearer with an example.</p>
</section>
</section>
<section id="simple-example-adding-an-extra-attribute-to-ndarray">
<h2>Simple example - adding an extra attribute to ndarray<a class="headerlink" href="#simple-example-adding-an-extra-attribute-to-ndarray" title="Permalink to this heading">#</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">InfoArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Create the ndarray instance of our type, given the usual</span>
        <span class="c1"># ndarray input arguments.  This will call the standard</span>
        <span class="c1"># ndarray constructor, but return an object of our type.</span>
        <span class="c1"># It also triggers a call to InfoArray.__array_finalize__</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                              <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="c1"># set the new &#39;info&#39; attribute to the value passed</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="c1"># Finally, we must return the newly created object:</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># ``self`` is a new object resulting from</span>
        <span class="c1"># ndarray.__new__(InfoArray, ...), therefore it only has</span>
        <span class="c1"># attributes that the ndarray.__new__ constructor gave it -</span>
        <span class="c1"># i.e. those of a standard ndarray.</span>
        <span class="c1">#</span>
        <span class="c1"># We could have got to the ndarray.__new__ call in 3 ways:</span>
        <span class="c1"># From an explicit constructor - e.g. InfoArray():</span>
        <span class="c1">#    obj is None</span>
        <span class="c1">#    (we&#39;re in the middle of the InfoArray.__new__</span>
        <span class="c1">#    constructor, and self.info will be set when we return to</span>
        <span class="c1">#    InfoArray.__new__)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># From view casting - e.g arr.view(InfoArray):</span>
        <span class="c1">#    obj is arr</span>
        <span class="c1">#    (type(obj) can be InfoArray)</span>
        <span class="c1"># From new-from-template - e.g infoarr[:3]</span>
        <span class="c1">#    type(obj) is InfoArray</span>
        <span class="c1">#</span>
        <span class="c1"># Note that it is here, rather than in the __new__ method,</span>
        <span class="c1"># that we set the default value for &#39;info&#39;, because this</span>
        <span class="c1"># method sees all creation of default objects - with the</span>
        <span class="c1"># InfoArray.__new__ constructor, but also with</span>
        <span class="c1"># arr.view(InfoArray).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># We do not need to return anything</span>
</pre></div>
</div>
<p>Using the object looks like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">InfoArray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span> <span class="c1"># explicit constructor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="go">&lt;class &#39;InfoArray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">InfoArray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="n">info</span><span class="o">=</span><span class="s1">&#39;information&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">info</span>
<span class="go">&#39;information&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># new-from-template - here - slicing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;class &#39;InfoArray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">info</span>
<span class="go">&#39;information&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">InfoArray</span><span class="p">)</span> <span class="c1"># view casting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">cast_arr</span><span class="p">)</span>
<span class="go">&lt;class &#39;InfoArray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast_arr</span><span class="o">.</span><span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This class isn’t very useful, because it has the same constructor as the
bare ndarray object, including passing in buffers and shapes and so on.
We would probably prefer the constructor to be able to take an already
formed ndarray from the usual numpy calls to <code class="docutils literal notranslate"><span class="pre">np.array</span></code> and return an
object.</p>
</section>
<section id="slightly-more-realistic-example-attribute-added-to-existing-array">
<h2>Slightly more realistic example - attribute added to existing array<a class="headerlink" href="#slightly-more-realistic-example-attribute-added-to-existing-array" title="Permalink to this heading">#</a></h2>
<p>Here is a class that takes a standard ndarray that already exists, casts
as our type, and adds an extra attribute.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">RealisticInfoArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_array</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Input array is an already formed ndarray instance</span>
        <span class="c1"># We first cast to be our class type</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="c1"># add the new attribute to the created instance</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="c1"># Finally, we must return the newly created object:</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># see InfoArray.__array_finalize__ for comments</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>So:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">RealisticInfoArray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="s1">&#39;information&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="go">&lt;class &#39;RealisticInfoArray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">info</span>
<span class="go">&#39;information&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;class &#39;RealisticInfoArray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">info</span>
<span class="go">&#39;information&#39;</span>
</pre></div>
</div>
</section>
<section id="array-ufunc-for-ufuncs">
<span id="array-ufunc"></span><h2><code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> for ufuncs<a class="headerlink" href="#array-ufunc-for-ufuncs" title="Permalink to this heading">#</a></h2>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.</span></p>
</div>
</div></blockquote>
<p>A subclass can override what happens when executing numpy ufuncs on it by
overriding the default <code class="docutils literal notranslate"><span class="pre">ndarray.__array_ufunc__</span></code> method. This method is
executed <em>instead</em> of the ufunc and should return either the result of the
operation, or <a class="reference external" href="https://docs.python.org/3/library/constants.html#NotImplemented" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> if the operation requested is not
implemented.</p>
<p>The signature of <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def __array_ufunc__(ufunc, method, *inputs, **kwargs):

- *ufunc* is the ufunc object that was called.
- *method* is a string indicating how the Ufunc was called, either
  ``&quot;__call__&quot;`` to indicate it was called directly, or one of its
  :ref:`methods&lt;ufuncs.methods&gt;`: ``&quot;reduce&quot;``, ``&quot;accumulate&quot;``,
  ``&quot;reduceat&quot;``, ``&quot;outer&quot;``, or ``&quot;at&quot;``.
- *inputs* is a tuple of the input arguments to the ``ufunc``
- *kwargs* contains any optional or keyword arguments passed to the
  function. This includes any ``out`` arguments, which are always
  contained in a tuple.
</pre></div>
</div>
<p>A typical implementation would convert any inputs or outputs that are
instances of one’s own class, pass everything on to a superclass using
<code class="docutils literal notranslate"><span class="pre">super()</span></code>, and finally return the results after possible
back-conversion. An example, taken from the test case
<code class="docutils literal notranslate"><span class="pre">test_ufunc_override_with_super</span></code> in <code class="docutils literal notranslate"><span class="pre">core/tests/test_umath.py</span></code>, is the
following.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">in_no</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">input_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
                <span class="n">in_no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_</span><span class="p">)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="n">out</span>
        <span class="n">out_no</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="n">out_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
                    <span class="n">out_no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">out_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span>

        <span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">in_no</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_no</span>
        <span class="k">if</span> <span class="n">out_no</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;outputs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_no</span>

        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;at&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="p">):</span>
                <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">,)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                         <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">output</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">outputs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="p">):</span>
            <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>

        <span class="k">return</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">results</span>
</pre></div>
</div>
<p>So, this class does not actually do anything interesting: it just
converts any instances of its own to regular ndarray (otherwise, we’d
get infinite recursion!), and adds an <code class="docutils literal notranslate"><span class="pre">info</span></code> dictionary that tells
which inputs and outputs it converted. Hence, e.g.,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">5.</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">info</span>
<span class="go">{&#39;inputs&#39;: [0]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">5.</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="p">(</span><span class="n">a</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">info</span>
<span class="go">{&#39;outputs&#39;: [0]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">5.</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">info</span>
<span class="go">{&#39;inputs&#39;: [0, 1]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+=</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">info</span>
<span class="go">{&#39;inputs&#39;: [0, 1], &#39;outputs&#39;: [0]}</span>
</pre></div>
</div>
<p>Note that another approach would be to use <code class="docutils literal notranslate"><span class="pre">getattr(ufunc,</span>
<span class="pre">methods)(*inputs,</span> <span class="pre">**kwargs)</span></code> instead of the <code class="docutils literal notranslate"><span class="pre">super</span></code> call. For this example,
the result would be identical, but there is a difference if another operand
also defines <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code>. E.g., lets assume that we evalulate
<code class="docutils literal notranslate"><span class="pre">np.add(a,</span> <span class="pre">b)</span></code>, where <code class="docutils literal notranslate"><span class="pre">b</span></code> is an instance of another class <code class="docutils literal notranslate"><span class="pre">B</span></code> that has
an override.  If you use <code class="docutils literal notranslate"><span class="pre">super</span></code> as in the example,
<code class="docutils literal notranslate"><span class="pre">ndarray.__array_ufunc__</span></code> will notice that <code class="docutils literal notranslate"><span class="pre">b</span></code> has an override, which
means it cannot evaluate the result itself. Thus, it will return
<em class="xref py py-obj">NotImplemented</em> and so will our class <code class="docutils literal notranslate"><span class="pre">A</span></code>. Then, control will be passed
over to <code class="docutils literal notranslate"><span class="pre">b</span></code>, which either knows how to deal with us and produces a result,
or does not and returns <em class="xref py py-obj">NotImplemented</em>, raising a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
<p>If instead, we replace our <code class="docutils literal notranslate"><span class="pre">super</span></code> call with <code class="docutils literal notranslate"><span class="pre">getattr(ufunc,</span> <span class="pre">method)</span></code>, we
effectively do <code class="docutils literal notranslate"><span class="pre">np.add(a.view(np.ndarray),</span> <span class="pre">b)</span></code>. Again, <code class="docutils literal notranslate"><span class="pre">B.__array_ufunc__</span></code>
will be called, but now it sees an <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> as the other argument. Likely,
it will know how to handle this, and return a new instance of the <code class="docutils literal notranslate"><span class="pre">B</span></code> class
to us. Our example class is not set up to handle this, but it might well be
the best approach if, e.g., one were to re-implement <code class="docutils literal notranslate"><span class="pre">MaskedArray</span></code> using
<code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code>.</p>
<p>As a final note: if the <code class="docutils literal notranslate"><span class="pre">super</span></code> route is suited to a given class, an
advantage of using it is that it helps in constructing class hierarchies.
E.g., suppose that our other class <code class="docutils literal notranslate"><span class="pre">B</span></code> also used the <code class="docutils literal notranslate"><span class="pre">super</span></code> in its
<code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> implementation, and we created a class <code class="docutils literal notranslate"><span class="pre">C</span></code> that depended
on both, i.e., <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">C(A,</span> <span class="pre">B)</span></code> (with, for simplicity, not another
<code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> override). Then any ufunc on an instance of <code class="docutils literal notranslate"><span class="pre">C</span></code> would
pass on to <code class="docutils literal notranslate"><span class="pre">A.__array_ufunc__</span></code>, the <code class="docutils literal notranslate"><span class="pre">super</span></code> call in <code class="docutils literal notranslate"><span class="pre">A</span></code> would go to
<code class="docutils literal notranslate"><span class="pre">B.__array_ufunc__</span></code>, and the <code class="docutils literal notranslate"><span class="pre">super</span></code> call in <code class="docutils literal notranslate"><span class="pre">B</span></code> would go to
<code class="docutils literal notranslate"><span class="pre">ndarray.__array_ufunc__</span></code>, thus allowing <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> to collaborate.</p>
</section>
<section id="array-wrap-for-ufuncs-and-other-functions">
<span id="array-wrap"></span><h2><code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> for ufuncs and other functions<a class="headerlink" href="#array-wrap-for-ufuncs-and-other-functions" title="Permalink to this heading">#</a></h2>
<p>Prior to numpy 1.13, the behaviour of ufuncs could only be tuned using
<code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> and <code class="docutils literal notranslate"><span class="pre">__array_prepare__</span></code>. These two allowed one to
change the output type of a ufunc, but, in contrast to
<code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code>, did not allow one to make any changes to the inputs.
It is hoped to eventually deprecate these, but <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> is also
used by other numpy functions and methods, such as <code class="docutils literal notranslate"><span class="pre">squeeze</span></code>, so at the
present time is still needed for full functionality.</p>
<p>Conceptually, <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> “wraps up the action” in the sense of
allowing a subclass to set the type of the return value and update
attributes and metadata.  Let’s show how this works with an example.  First
we return to the simpler example subclass, but with a different name and
some print statements:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">MySubClass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_array</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In __array_finalize__:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   self is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   obj is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In __array_wrap__:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   self is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   arr is </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">out_arr</span><span class="p">))</span>
        <span class="c1"># then just call the parent</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
<p>We run a ufunc on an instance of our new array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">MySubClass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">info</span><span class="o">=</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="go">In __array_finalize__:</span>
<span class="go">   self is MySubClass([0, 1, 2, 3, 4])</span>
<span class="go">   obj is array([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arr2</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
<span class="go">In __array_wrap__:</span>
<span class="go">   self is MySubClass([0, 1, 2, 3, 4])</span>
<span class="go">   arr is array([1, 3, 5, 7, 9])</span>
<span class="go">In __array_finalize__:</span>
<span class="go">   self is MySubClass([1, 3, 5, 7, 9])</span>
<span class="go">   obj is MySubClass([0, 1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span>
<span class="go">MySubClass([1, 3, 5, 7, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span><span class="o">.</span><span class="n">info</span>
<span class="go">&#39;spam&#39;</span>
</pre></div>
</div>
<p>Note that the ufunc (<code class="docutils literal notranslate"><span class="pre">np.add</span></code>) has called the <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> method
with arguments <code class="docutils literal notranslate"><span class="pre">self</span></code> as <code class="docutils literal notranslate"><span class="pre">obj</span></code>, and <code class="docutils literal notranslate"><span class="pre">out_arr</span></code> as the (ndarray) result
of the addition.  In turn, the default <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code>
(<code class="docutils literal notranslate"><span class="pre">ndarray.__array_wrap__</span></code>) has cast the result to class <code class="docutils literal notranslate"><span class="pre">MySubClass</span></code>,
and called <code class="docutils literal notranslate"><span class="pre">__array_finalize__</span></code> - hence the copying of the <code class="docutils literal notranslate"><span class="pre">info</span></code>
attribute.  This has all happened at the C level.</p>
<p>But, we could do anything we wanted:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SillySubClass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;I lost your data&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">arr1</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">SillySubClass</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">arr2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span>
<span class="go">&#39;I lost your data&#39;</span>
</pre></div>
</div>
<p>So, by defining a specific <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> method for our subclass,
we can tweak the output from ufuncs. The <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> method
requires <code class="docutils literal notranslate"><span class="pre">self</span></code>, then an argument - which is the result of the ufunc -
and an optional parameter <em>context</em>. This parameter is returned by
ufuncs as a 3-element tuple: (name of the ufunc, arguments of the ufunc,
domain of the ufunc), but is not set by other numpy functions. Though,
as seen above, it is possible to do otherwise, <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code> should
return an instance of its containing class.  See the masked array
subclass for an implementation.</p>
<p>In addition to <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code>, which is called on the way out of the
ufunc, there is also an <code class="docutils literal notranslate"><span class="pre">__array_prepare__</span></code> method which is called on
the way into the ufunc, after the output arrays are created but before any
computation has been performed. The default implementation does nothing
but pass through the array. <code class="docutils literal notranslate"><span class="pre">__array_prepare__</span></code> should not attempt to
access the array data or resize the array, it is intended for setting the
output array type, updating attributes and metadata, and performing any
checks based on the input that may be desired before computation begins.
Like <code class="docutils literal notranslate"><span class="pre">__array_wrap__</span></code>, <code class="docutils literal notranslate"><span class="pre">__array_prepare__</span></code> must return an ndarray or
subclass thereof or raise an error.</p>
</section>
<section id="extra-gotchas-custom-del-methods-and-ndarray-base">
<h2>Extra gotchas - custom <code class="docutils literal notranslate"><span class="pre">__del__</span></code> methods and ndarray.base<a class="headerlink" href="#extra-gotchas-custom-del-methods-and-ndarray-base" title="Permalink to this heading">#</a></h2>
<p>One of the problems that ndarray solves is keeping track of memory
ownership of ndarrays and their views.  Consider the case where we have
created an ndarray, <code class="docutils literal notranslate"><span class="pre">arr</span></code> and have taken a slice with <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">arr[1:]</span></code>.
The two objects are looking at the same memory.  NumPy keeps track of
where the data came from for a particular array or view, with the
<code class="docutils literal notranslate"><span class="pre">base</span></code> attribute:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># A normal ndarray, that owns its own data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># In this case, base is None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># We take a view</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># base now points to the array that it derived from</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">arr</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Take a view of a view</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># base points to the original array that it was derived from</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">arr</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In general, if the array owns its own memory, as for <code class="docutils literal notranslate"><span class="pre">arr</span></code> in this
case, then <code class="docutils literal notranslate"><span class="pre">arr.base</span></code> will be None - there are some exceptions to this
- see the numpy book for more details.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">base</span></code> attribute is useful in being able to tell whether we have
a view or the original array.  This in turn can be useful if we need
to know whether or not to do some specific cleanup when the subclassed
array is deleted.  For example, we may only want to do the cleanup if
the original array is deleted, but not the views.  For an example of
how this can work, have a look at the <code class="docutils literal notranslate"><span class="pre">memmap</span></code> class in
<code class="docutils literal notranslate"><span class="pre">numpy.core</span></code>.</p>
</section>
<section id="subclassing-and-downstream-compatibility">
<h2>Subclassing and Downstream Compatibility<a class="headerlink" href="#subclassing-and-downstream-compatibility" title="Permalink to this heading">#</a></h2>
<p>When sub-classing <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> or creating duck-types that mimic the <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>
interface, it is your responsibility to decide how aligned your APIs will be
with those of numpy. For convenience, many numpy functions that have a corresponding
<code class="docutils literal notranslate"><span class="pre">ndarray</span></code> method (e.g., <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">take</span></code>, <code class="docutils literal notranslate"><span class="pre">reshape</span></code>) work by checking
if the first argument to a function has a method of the same name. If it exists, the
method is called instead of coercing the arguments to a numpy array.</p>
<p>For example, if you want your sub-class or duck-type to be compatible with
numpy’s <code class="docutils literal notranslate"><span class="pre">sum</span></code> function, the method signature for this object’s <code class="docutils literal notranslate"><span class="pre">sum</span></code> method
should be the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="o">...</span>
</pre></div>
</div>
<p>This is the exact same method signature for <code class="docutils literal notranslate"><span class="pre">np.sum</span></code>, so now if a user calls
<code class="docutils literal notranslate"><span class="pre">np.sum</span></code> on this object, numpy will call the object’s own <code class="docutils literal notranslate"><span class="pre">sum</span></code> method and
pass in these arguments enumerated above in the signature, and no errors will
be raised because the signatures are completely compatible with each other.</p>
<p>If, however, you decide to deviate from this signature and do something like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="o">...</span>
</pre></div>
</div>
<p>This object is no longer compatible with <code class="docutils literal notranslate"><span class="pre">np.sum</span></code> because if you call <code class="docutils literal notranslate"><span class="pre">np.sum</span></code>,
it will pass in unexpected arguments <code class="docutils literal notranslate"><span class="pre">out</span></code> and <code class="docutils literal notranslate"><span class="pre">keepdims</span></code>, causing a TypeError
to be raised.</p>
<p>If you wish to maintain compatibility with numpy and its subsequent versions (which
might add new keyword arguments) but do not want to surface all of numpy’s arguments,
your function’s signature should accept <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">unused_kwargs</span><span class="p">):</span>
<span class="o">...</span>
</pre></div>
</div>
<p>This object is now compatible with <code class="docutils literal notranslate"><span class="pre">np.sum</span></code> again because any extraneous arguments
(i.e. keywords that are not <code class="docutils literal notranslate"><span class="pre">axis</span></code> or <code class="docutils literal notranslate"><span class="pre">dtype</span></code>) will be hidden away in the
<code class="docutils literal notranslate"><span class="pre">**unused_kwargs</span></code> parameter.</p>
</section>
</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="basics.dispatch.html" title="previous page">
      <i class="fas fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Writing custom array containers</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="basics.interoperability.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">Interoperability with NumPy</p>
  </div>
  <i class="fas fa-angle-right"></i>
  </a>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2008-2022, NumPy Developers.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>