
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Beyond the Basics &#8212; NumPy v1.24 Manual</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/numpy.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script async="async" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="F2PY user guide and reference manual" href="../f2py/index.html" />
    <link rel="prev" title="Writing your own ufunc" href="c-info.ufunc-tutorial.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="light">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../index.html">
  
  
  
  
    <img src="../_static/numpylogo.svg" class="logo__image only-light" alt="Logo image">
    <img src="../_static/numpylogo_dark.svg" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../reference/index.html">
  API reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../dev/index.html">
  Development
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../release.html">
  Release notes
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://numpy.org/numpy-tutorials/">Learn<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <div class="dropdown" id="version_switcher">
    <button type="button" class="btn btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        1.24  <!-- this text may get changed later by javascript -->
        <span class="caret"></span>
    </button>
    <div id="version_switcher_menu" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<!-- NOTE: this JS must live here (not in our global JS file) because it relies
     on being processed by Jinja before it is run (specifically for replacing
     variables user/c-info.beyond-basics and {'version_match': '1.24', 'json_url': 'https://numpy.org/doc/_static/versions.json'}.
-->

<script type="text/javascript">
// Check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "user/c-info.beyond-basics.html",
          tryUrl = event.target.getAttribute("href");
    let otherDocsHomepage = tryUrl.replace(currentFilePath, "");
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    // this prevents the browser from following the href of the clicked node
    // (which is fine because this function takes care of redirecting)
    return false;
}

// Populate the version switcher from the JSON config file
(function () {
    $.getJSON("https://numpy.org/doc/_static/versions.json", function(data, textStatus, jqXHR) {
        const currentFilePath = "user/c-info.beyond-basics.html";
        let btn = document.getElementById("version_switcher_button");
        // Set empty strings by default so that these attributes exist and can be used in CSS selectors
        btn.dataset["activeVersionName"] = "";
        btn.dataset["activeVersion"] = "";
        // create links to the corresponding page in the other docs versions
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // create the node
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.textContent = `${entry.name}`;
            node.setAttribute("href", `${entry.url}${currentFilePath}`);
            // on click, AJAX calls will check if the linked page exists before
            // trying to redirect, and if not, will redirect to the homepage
            // for that version of the docs.
            node.onclick = checkPageExistsAndRedirect;
            // Add dataset values for the version and name in case people want
            // to apply CSS styling based on this information.
            node.dataset["versionName"] = entry.name;
            node.dataset["version"] = entry.version;

            $("#version_switcher_menu").append(node);
            // replace dropdown button text with the preferred display name of
            // this version, rather than using sphinx's 1.24 variable.
            // also highlight the dropdown entry for the currently-viewed
            // version's entry
            if (entry.version == "1.24") {
                node.classList.add("active");
                btn.innerText = btn.dataset["activeVersionName"] = entry.name;
                btn.dataset["activeVersion"] = entry.version;
            }
        });
    });
})();
</script>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/numpy/numpy" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/numpy_team" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="whatisnumpy.html">
   What is NumPy?
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://numpy.org/install/">
   Installation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="quickstart.html">
   NumPy quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="absolute_beginners.html">
   NumPy: the absolute basics for beginners
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Fundamentals and usage
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="basics.html">
   NumPy fundamentals
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="numpy-for-matlab-users.html">
   NumPy for MATLAB users
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference external" href="https://numpy.org/numpy-tutorials/features.html">
   NumPy Tutorials
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="howtos_index.html">
   NumPy How Tos
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Advanced usage and interoperability
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="building.html">
   Building from source
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="c-info.html">
   Using NumPy C-API
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="c-info.how-to-extend.html">
     How to extend NumPy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="c-info.python-as-glue.html">
     Using Python as glue
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="c-info.ufunc-tutorial.html">
     Writing your own ufunc
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Beyond the Basics
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../f2py/index.html">
   F2PY user guide and reference manual
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dev/underthehood.html">
   Under-the-hood documentation for developers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="basics.interoperability.html">
   Interoperability with NumPy
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Extras
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../glossary.html">
   Glossary
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../release.html">
   Release notes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../license.html">
   NumPy license
  </a>
 </li>
</ul>

  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#iterating-over-elements-in-the-array">
   Iterating over elements in the array
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#basic-iteration">
     Basic Iteration
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#iterating-over-all-but-one-axis">
     Iterating over all but one axis
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#iterating-over-multiple-arrays">
     Iterating over multiple arrays
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#broadcasting-over-multiple-arrays">
     Broadcasting over multiple arrays
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#user-defined-data-types">
   User-defined data-types
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adding-the-new-data-type">
     Adding the new data-type
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#registering-a-casting-function">
     Registering a casting function
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#registering-coercion-rules">
     Registering coercion rules
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#registering-a-ufunc-loop">
     Registering a ufunc loop
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#subtyping-the-ndarray-in-c">
   Subtyping the ndarray in C
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#creating-sub-types">
     Creating sub-types
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#specific-features-of-ndarray-sub-typing">
     Specific features of ndarray sub-typing
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-array-finalize-method">
       The __array_finalize__ method
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#ndarray.__array_finalize__">
         <code class="docutils literal notranslate">
          <span class="pre">
           ndarray.__array_finalize__
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-array-priority-attribute">
       The __array_priority__ attribute
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#ndarray.__array_priority__">
         <code class="docutils literal notranslate">
          <span class="pre">
           ndarray.__array_priority__
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-array-wrap-method">
       The __array_wrap__ method
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#ndarray.__array_wrap__">
         <code class="docutils literal notranslate">
          <span class="pre">
           ndarray.__array_wrap__
          </span>
         </code>
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="beyond-the-basics">
<h1>Beyond the Basics<a class="headerlink" href="#beyond-the-basics" title="Permalink to this heading">#</a></h1>
<div class="line-block">
<div class="line">The voyage of discovery is not in seeking new landscapes but in having</div>
<div class="line">new eyes.</div>
<div class="line">— <em>Marcel Proust</em></div>
</div>
<div class="line-block">
<div class="line">Discovery is seeing what everyone else has seen and thinking what no</div>
<div class="line">one else has thought.</div>
<div class="line">— <em>Albert Szent-Gyorgi</em></div>
</div>
<section id="iterating-over-elements-in-the-array">
<h2>Iterating over elements in the array<a class="headerlink" href="#iterating-over-elements-in-the-array" title="Permalink to this heading">#</a></h2>
<section id="basic-iteration">
<span id="sec-array-iterator"></span><h3>Basic Iteration<a class="headerlink" href="#basic-iteration" title="Permalink to this heading">#</a></h3>
<p>One common algorithmic requirement is to be able to walk over all
elements in a multidimensional array. The array iterator object makes
this easy to do in a generic way that works for arrays of any
dimension. Naturally, if you know the number of dimensions you will be
using, then you can always write nested for loops to accomplish the
iteration. If, however, you want to write code that works with any
number of dimensions, then you can make use of the array iterator. An
array iterator object is returned when accessing the .flat attribute
of an array.</p>
<p id="index-0">Basic usage is to call <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_IterNew" title="PyArray_IterNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_IterNew</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">array</span></code> ) where array
is an ndarray object (or one of its sub-classes). The returned object
is an array-iterator object (the same object returned by the .flat
attribute of the ndarray). This object is usually cast to
PyArrayIterObject* so that its members can be accessed. The only
members that are needed are <code class="docutils literal notranslate"><span class="pre">iter-&gt;size</span></code> which contains the total
size of the array, <code class="docutils literal notranslate"><span class="pre">iter-&gt;index</span></code>, which contains the current 1-d
index into the array, and <code class="docutils literal notranslate"><span class="pre">iter-&gt;dataptr</span></code> which is a pointer to the
data for the current element of the array.  Sometimes it is also
useful to access <code class="docutils literal notranslate"><span class="pre">iter-&gt;ao</span></code> which is a pointer to the underlying
ndarray object.</p>
<p>After processing data at the current element of the array, the next
element of the array can be obtained using the macro
<a class="reference internal" href="../reference/c-api/array.html#c.PyArray_ITER_NEXT" title="PyArray_ITER_NEXT"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_NEXT</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">iter</span></code> ). The iteration always proceeds in a
C-style contiguous fashion (last index varying the fastest). The
<a class="reference internal" href="../reference/c-api/array.html#c.PyArray_ITER_GOTO" title="PyArray_ITER_GOTO"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_GOTO</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">iter</span></code>, <code class="docutils literal notranslate"><span class="pre">destination</span></code> ) can be used to
jump to a particular point in the array, where <code class="docutils literal notranslate"><span class="pre">destination</span></code> is an
array of npy_intp data-type with space to handle at least the number
of dimensions in the underlying array. Occasionally it is useful to
use <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_ITER_GOTO1D" title="PyArray_ITER_GOTO1D"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_GOTO1D</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">iter</span></code>, <code class="docutils literal notranslate"><span class="pre">index</span></code> ) which will jump
to the 1-d index given by the value of <code class="docutils literal notranslate"><span class="pre">index</span></code>. The most common
usage, however, is given in the following example.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">;</span><span class="w"> </span><span class="cm">/* assumed to be some ndarray object */</span><span class="w"></span>
<span class="n">PyArrayIterObject</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyArrayIterObject</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">PyArray_IterNew</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Assume fail has clean-up code */</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* do something with the data at it-&gt;dataptr */</span><span class="w"></span>
<span class="w">    </span><span class="n">PyArray_ITER_NEXT</span><span class="p">(</span><span class="n">it</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>You can also use <a class="reference internal" href="../reference/c-api/array.html#c.PyArrayIter_Check" title="PyArrayIter_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArrayIter_Check</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">obj</span></code> ) to ensure you have
an iterator object and <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_ITER_RESET" title="PyArray_ITER_RESET"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_RESET</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">iter</span></code> ) to reset an
iterator object back to the beginning of the array.</p>
<p>It should be emphasized at this point that you may not need the array
iterator if your array is already contiguous (using an array iterator
will work but will be slower than the fastest code you could write).
The major purpose of array iterators is to encapsulate iteration over
N-dimensional arrays with arbitrary strides. They are used in many,
many places in the NumPy source code itself. If you already know your
array is contiguous (Fortran or C), then simply adding the element-
size to a running pointer variable will step you through the array
very efficiently. In other words, code like this will probably be
faster for you in the contiguous case (assuming doubles).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">;</span><span class="w">  </span><span class="cm">/* could make this any variable type */</span><span class="w"></span>
<span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyArray_SIZE</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w"></span>
<span class="n">dptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyArray_DATA</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w"></span>
<span class="k">while</span><span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="cm">/* do something with the data at dptr */</span><span class="w"></span>
<span class="w">   </span><span class="n">dptr</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="iterating-over-all-but-one-axis">
<h3>Iterating over all but one axis<a class="headerlink" href="#iterating-over-all-but-one-axis" title="Permalink to this heading">#</a></h3>
<p>A common algorithm is to loop over all elements of an array and
perform some function with each element by issuing a function call. As
function calls can be time consuming, one way to speed up this kind of
algorithm is to write the function so it takes a vector of data and
then write the iteration so the function call is performed for an
entire dimension of data at a time. This increases the amount of work
done per function call, thereby reducing the function-call over-head
to a small(er) fraction of the total time. Even if the interior of the
loop is performed without a function call it can be advantageous to
perform the inner loop over the dimension with the highest number of
elements to take advantage of speed enhancements available on micro-
processors that use pipelining to enhance fundamental operations.</p>
<p>The <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_IterAllButAxis" title="PyArray_IterAllButAxis"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_IterAllButAxis</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">array</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;dim</span></code> ) constructs an
iterator object that is modified so that it will not iterate over the
dimension indicated by dim. The only restriction on this iterator
object, is that the <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_ITER_GOTO1D" title="PyArray_ITER_GOTO1D"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_GOTO1D</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">it</span></code>, <code class="docutils literal notranslate"><span class="pre">ind</span></code> ) macro
cannot be used (thus flat indexing won’t work either if you pass this
object back to Python — so you shouldn’t do this). Note that the
returned object from this routine is still usually cast to
PyArrayIterObject *. All that’s been done is to modify the strides
and dimensions of the returned iterator to simulate iterating over
array[…,0,…] where 0 is placed on the
<span class="math notranslate nohighlight">\(\textrm{dim}^{\textrm{th}}\)</span> dimension. If dim is negative, then
the dimension with the largest axis is found and used.</p>
</section>
<section id="iterating-over-multiple-arrays">
<h3>Iterating over multiple arrays<a class="headerlink" href="#iterating-over-multiple-arrays" title="Permalink to this heading">#</a></h3>
<p>Very often, it is desirable to iterate over several arrays at the
same time. The universal functions are an example of this kind of
behavior. If all you want to do is iterate over arrays with the same
shape, then simply creating several iterator objects is the standard
procedure. For example, the following code iterates over two arrays
assumed to be the same shape and size (actually obj1 just has to have
at least as many total elements as does obj2):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* It is already assumed that obj1 and obj2</span>
<span class="cm">   are ndarrays of the same shape and size.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="n">iter1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyArrayIterObject</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">PyArray_IterNew</span><span class="p">(</span><span class="n">obj1</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w"></span>
<span class="n">iter2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyArrayIterObject</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">PyArray_IterNew</span><span class="p">(</span><span class="n">obj2</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">goto</span><span class="w"> </span><span class="n">fail</span><span class="p">;</span><span class="w">  </span><span class="cm">/* assume iter1 is DECREF&#39;d at fail */</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">iter2</span><span class="o">-&gt;</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iter2</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* process with iter1-&gt;dataptr and iter2-&gt;dataptr */</span><span class="w"></span>
<span class="w">    </span><span class="n">PyArray_ITER_NEXT</span><span class="p">(</span><span class="n">iter1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">PyArray_ITER_NEXT</span><span class="p">(</span><span class="n">iter2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="broadcasting-over-multiple-arrays">
<h3>Broadcasting over multiple arrays<a class="headerlink" href="#broadcasting-over-multiple-arrays" title="Permalink to this heading">#</a></h3>
<p id="index-1">When multiple arrays are involved in an operation, you may want to use the
same broadcasting rules that the math operations (<em>i.e.</em> the ufuncs) use.
This can be done easily using the <a class="reference internal" href="../reference/c-api/types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyArrayMultiIterObject</span></code></a>.  This is
the object returned from the Python command numpy.broadcast and it is almost
as easy to use from C. The function
<a class="reference internal" href="../reference/c-api/array.html#c.PyArray_MultiIterNew" title="PyArray_MultiIterNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIterNew</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">...</span></code> ) is used (with <code class="docutils literal notranslate"><span class="pre">n</span></code> input
objects in place of <code class="docutils literal notranslate"><span class="pre">...</span></code> ). The input objects can be arrays or anything
that can be converted into an array. A pointer to a PyArrayMultiIterObject is
returned.  Broadcasting has already been accomplished which adjusts the
iterators so that all that needs to be done to advance to the next element in
each array is for PyArray_ITER_NEXT to be called for each of the inputs. This
incrementing is automatically performed by
<a class="reference internal" href="../reference/c-api/array.html#c.PyArray_MultiIter_NEXT" title="PyArray_MultiIter_NEXT"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_NEXT</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">obj</span></code> ) macro (which can handle a
multiterator <code class="docutils literal notranslate"><span class="pre">obj</span></code> as either a <span class="c-expr sig sig-inline c"><a class="reference internal" href="../reference/c-api/types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject"><span class="n">PyArrayMultiIterObject</span></a><span class="p">*</span></span> or a
<span class="c-expr sig sig-inline c"><a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject" title="(in Python v3.11)"><span class="n">PyObject</span></a><span class="p">*</span></span>). The data from input number <code class="docutils literal notranslate"><span class="pre">i</span></code> is available using
<a class="reference internal" href="../reference/c-api/array.html#c.PyArray_MultiIter_DATA" title="PyArray_MultiIter_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_DATA</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span></code> ). An example of using this
feature follows.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">mobj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyArray_MultiIterNew</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">obj1</span><span class="p">,</span><span class="w"> </span><span class="n">obj2</span><span class="p">);</span><span class="w"></span>
<span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mobj</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="k">while</span><span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyArray_MultiIter_DATA</span><span class="p">(</span><span class="n">mobj</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyArray_MultiIter_DATA</span><span class="p">(</span><span class="n">mobj</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* code using contents of ptr1 and ptr2 */</span><span class="w"></span>
<span class="w">    </span><span class="n">PyArray_MultiIter_NEXT</span><span class="p">(</span><span class="n">mobj</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_RemoveSmallest" title="PyArray_RemoveSmallest"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_RemoveSmallest</span></code></a> ( <code class="docutils literal notranslate"><span class="pre">multi</span></code> ) can be used to
take a multi-iterator object and adjust all the iterators so that
iteration does not take place over the largest dimension (it makes
that dimension of size 1). The code being looped over that makes use
of the pointers will very-likely also need the strides data for each
of the iterators. This information is stored in
multi-&gt;iters[i]-&gt;strides.</p>
<p id="index-2">There are several examples of using the multi-iterator in the NumPy
source code as it makes N-dimensional broadcasting-code very simple to
write. Browse the source for more examples.</p>
</section>
</section>
<section id="user-defined-data-types">
<span id="user-user-defined-data-types"></span><h2>User-defined data-types<a class="headerlink" href="#user-defined-data-types" title="Permalink to this heading">#</a></h2>
<p>NumPy comes with 24 builtin data-types. While this covers a large
majority of possible use cases, it is conceivable that a user may have
a need for an additional data-type. There is some support for adding
an additional data-type into the NumPy system. This additional data-
type will behave much like a regular data-type except ufuncs must have
1-d loops registered to handle it separately. Also checking for
whether or not other data-types can be cast “safely” to and from this
new type or not will always return “can cast” unless you also register
which types your new data-type can be cast to and from.</p>
<p>The NumPy source code includes an example of a custom data-type as part
of its test suite. The file <code class="docutils literal notranslate"><span class="pre">_rational_tests.c.src</span></code> in the source code
directory  <code class="docutils literal notranslate"><span class="pre">numpy/numpy/core/src/umath/</span></code> contains an implementation of
a data-type that represents a rational number as the ratio of two 32 bit
integers.</p>
<section id="adding-the-new-data-type">
<span id="index-3"></span><h3>Adding the new data-type<a class="headerlink" href="#adding-the-new-data-type" title="Permalink to this heading">#</a></h3>
<p>To begin to make use of the new data-type, you need to first define a
new Python type to hold the scalars of your new data-type. It should
be acceptable to inherit from one of the array scalars if your new
type has a binary compatible layout. This will allow your new data
type to have the methods and attributes of array scalars. New data-
types must have a fixed memory size (if you want to define a data-type
that needs a flexible representation, like a variable-precision
number, then use a pointer to the object as the data-type). The memory
layout of the object structure for the new Python type must be
PyObject_HEAD followed by the fixed-size memory needed for the data-
type. For example, a suitable structure for the new Python type is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">PyObject_HEAD</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">some_data_type</span><span class="w"> </span><span class="n">obval</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="cm">/* the name can be whatever you want */</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">PySomeDataTypeObject</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>After you have defined a new Python type object, you must then define
a new <a class="reference internal" href="../reference/c-api/types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyArray_Descr</span></code></a> structure whose typeobject member will contain a
pointer to the data-type you’ve just defined. In addition, the
required functions in the “.f” member must be defined: nonzero,
copyswap, copyswapn, setitem, getitem, and cast. The more functions in
the “.f” member you define, however, the more useful the new data-type
will be.  It is very important to initialize unused functions to NULL.
This can be achieved using <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_InitArrFuncs" title="PyArray_InitArrFuncs"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_InitArrFuncs</span></code></a> (f).</p>
<p>Once a new <a class="reference internal" href="../reference/c-api/types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyArray_Descr</span></code></a> structure is created and filled with the
needed information and useful functions you call
<a class="reference internal" href="../reference/c-api/array.html#c.PyArray_RegisterDataType" title="PyArray_RegisterDataType"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_RegisterDataType</span></code></a> (new_descr). The return value from this
call is an integer providing you with a unique type_number that
specifies your data-type. This type number should be stored and made
available by your module so that other modules can use it to recognize
your data-type (the other mechanism for finding a user-defined
data-type number is to search based on the name of the type-object
associated with the data-type using <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_TypeNumFromName" title="PyArray_TypeNumFromName"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_TypeNumFromName</span></code></a> ).</p>
</section>
<section id="registering-a-casting-function">
<h3>Registering a casting function<a class="headerlink" href="#registering-a-casting-function" title="Permalink to this heading">#</a></h3>
<p>You may want to allow builtin (and other user-defined) data-types to
be cast automatically to your data-type. In order to make this
possible, you must register a casting function with the data-type you
want to be able to cast from. This requires writing low-level casting
functions for each conversion you want to support and then registering
these functions with the data-type descriptor. A low-level casting
function has the signature.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.castfunc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">castfunc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">from</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">to</span></span>, <a class="reference internal" href="../reference/c-api/dtype.html#c.npy_intp" title="npy_intp"><span class="n"><span class="pre">npy_intp</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fromarr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">toarr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.castfunc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Cast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements <code class="docutils literal notranslate"><span class="pre">from</span></code> one type <code class="docutils literal notranslate"><span class="pre">to</span></code> another. The data to
cast from is in a contiguous, correctly-swapped and aligned chunk
of memory pointed to by from. The buffer to cast to is also
contiguous, correctly-swapped and aligned. The fromarr and toarr
arguments should only be used for flexible-element-sized arrays
(string, unicode, void).</p>
</dd></dl>

<p>An example castfunc is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="nf">double_to_float</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">npy_intp</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ignore1</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ignore2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="o">*</span><span class="n">to</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">from</span><span class="o">++</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This could then be registered to convert doubles to floats using the
code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">doub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyArray_DescrFromType</span><span class="p">(</span><span class="n">NPY_DOUBLE</span><span class="p">);</span><span class="w"></span>
<span class="n">PyArray_RegisterCastFunc</span><span class="p">(</span><span class="n">doub</span><span class="p">,</span><span class="w"> </span><span class="n">NPY_FLOAT</span><span class="p">,</span><span class="w"></span>
<span class="w">     </span><span class="p">(</span><span class="n">PyArray_VectorUnaryFunc</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">double_to_float</span><span class="p">);</span><span class="w"></span>
<span class="n">Py_DECREF</span><span class="p">(</span><span class="n">doub</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="registering-coercion-rules">
<h3>Registering coercion rules<a class="headerlink" href="#registering-coercion-rules" title="Permalink to this heading">#</a></h3>
<p>By default, all user-defined data-types are not presumed to be safely
castable to any builtin data-types. In addition builtin data-types are
not presumed to be safely castable to user-defined data-types. This
situation limits the ability of user-defined data-types to participate
in the coercion system used by ufuncs and other times when automatic
coercion takes place in NumPy. This can be changed by registering
data-types as safely castable from a particular data-type object. The
function <a class="reference internal" href="../reference/c-api/array.html#c.PyArray_RegisterCanCast" title="PyArray_RegisterCanCast"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_RegisterCanCast</span></code></a> (from_descr, totype_number,
scalarkind) should be used to specify that the data-type object
from_descr can be cast to the data-type with type number
totype_number. If you are not trying to alter scalar coercion rules,
then use <a class="reference internal" href="../reference/c-api/array.html#c.NPY_SCALARKIND.NPY_NOSCALAR" title="NPY_NOSCALAR"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">NPY_NOSCALAR</span></code></a> for the scalarkind argument.</p>
<p>If you want to allow your new data-type to also be able to share in
the scalar coercion rules, then you need to specify the scalarkind
function in the data-type object’s “.f” member to return the kind of
scalar the new data-type should be seen as (the value of the scalar is
available to that function). Then, you can register data-types that
can be cast to separately for each scalar kind that may be returned
from your user-defined data-type. If you don’t register scalar
coercion handling, then all of your user-defined data-types will be
seen as <a class="reference internal" href="../reference/c-api/array.html#c.NPY_SCALARKIND.NPY_NOSCALAR" title="NPY_NOSCALAR"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">NPY_NOSCALAR</span></code></a>.</p>
</section>
<section id="registering-a-ufunc-loop">
<h3>Registering a ufunc loop<a class="headerlink" href="#registering-a-ufunc-loop" title="Permalink to this heading">#</a></h3>
<p>You may also want to register low-level ufunc loops for your data-type
so that an ndarray of your data-type can have math applied to it
seamlessly. Registering a new loop with exactly the same arg_types
signature, silently replaces any previously registered loops for that
data-type.</p>
<p>Before you can register a 1-d loop for a ufunc, the ufunc must be
previously created. Then you call <a class="reference internal" href="../reference/c-api/ufunc.html#c.PyUFunc_RegisterLoopForType" title="PyUFunc_RegisterLoopForType"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUFunc_RegisterLoopForType</span></code></a>
(…) with the information needed for the loop. The return value of
this function is <code class="docutils literal notranslate"><span class="pre">0</span></code> if the process was successful and <code class="docutils literal notranslate"><span class="pre">-1</span></code> with
an error condition set if it was not successful.</p>
</section>
</section>
<section id="subtyping-the-ndarray-in-c">
<span id="index-4"></span><h2>Subtyping the ndarray in C<a class="headerlink" href="#subtyping-the-ndarray-in-c" title="Permalink to this heading">#</a></h2>
<p>One of the lesser-used features that has been lurking in Python since
2.2 is the ability to sub-class types in C. This facility is one of
the important reasons for basing NumPy off of the Numeric code-base
which was already in C. A sub-type in C allows much more flexibility
with regards to memory management. Sub-typing in C is not difficult
even if you have only a rudimentary understanding of how to create new
types for Python. While it is easiest to sub-type from a single parent
type, sub-typing from multiple parent types is also possible. Multiple
inheritance in C is generally less useful than it is in Python because
a restriction on Python sub-types is that they have a binary
compatible memory layout. Perhaps for this reason, it is somewhat
easier to sub-type from a single parent type.</p>
<p id="index-5">All C-structures corresponding to Python objects must begin with
<a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD" title="(in Python v3.11)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_HEAD</span></code></a> (or <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject_VAR_HEAD" title="(in Python v3.11)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_VAR_HEAD</span></code></a>). In the same
way, any sub-type must have a C-structure that begins with exactly the
same memory layout as the parent type (or all of the parent types in
the case of multiple-inheritance). The reason for this is that Python
may attempt to access a member of the sub-type structure as if it had
the parent structure ( <em>i.e.</em> it will cast a given pointer to a
pointer to the parent structure and then dereference one of it’s
members). If the memory layouts are not compatible, then this attempt
will cause unpredictable behavior (eventually leading to a memory
violation and program crash).</p>
<p>One of the elements in <a class="reference external" href="https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD" title="(in Python v3.11)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_HEAD</span></code></a> is a pointer to a
type-object structure. A new Python type is created by creating a new
type-object structure and populating it with functions and pointers to
describe the desired behavior of the type. Typically, a new
C-structure is also created to contain the instance-specific
information needed for each object of the type as well. For example,
<a class="reference internal" href="../reference/c-api/types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">&amp;PyArray_Type</span></code></a> is a pointer to the type-object table for the ndarray
while a <span class="c-expr sig sig-inline c"><a class="reference internal" href="../reference/c-api/types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><span class="n">PyArrayObject</span></a><span class="p">*</span></span> variable is a pointer to a particular instance
of an ndarray (one of the members of the ndarray structure is, in
turn, a pointer to the type- object table <a class="reference internal" href="../reference/c-api/types-and-structures.html#c.PyArray_Type" title="PyArray_Type"><code class="xref c c-data docutils literal notranslate"><span class="pre">&amp;PyArray_Type</span></code></a>). Finally
<a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyType_Ready" title="(in Python v3.11)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready</span></code></a> (&lt;pointer_to_type_object&gt;) must be called for
every new Python type.</p>
<section id="creating-sub-types">
<h3>Creating sub-types<a class="headerlink" href="#creating-sub-types" title="Permalink to this heading">#</a></h3>
<p>To create a sub-type, a similar procedure must be followed except
only behaviors that are different require new entries in the type-
object structure. All other entries can be NULL and will be filled in
by <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyType_Ready" title="(in Python v3.11)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready</span></code></a> with appropriate functions from the parent
type(s). In particular, to create a sub-type in C follow these steps:</p>
<ol class="arabic">
<li><p>If needed create a new C-structure to handle each instance of your
type. A typical C-structure would be:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">_new_struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">PyArrayObject</span><span class="w"> </span><span class="n">base</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* new things here */</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">NewArrayObject</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the full PyArrayObject is used as the first entry in order
to ensure that the binary layout of instances of the new type is
identical to the PyArrayObject.</p>
</li>
<li><p>Fill in a new Python type-object structure with pointers to new
functions that will over-ride the default behavior while leaving any
function that should remain the same unfilled (or NULL). The tp_name
element should be different.</p></li>
<li><p>Fill in the tp_base member of the new type-object structure with a
pointer to the (main) parent type object. For multiple-inheritance,
also fill in the tp_bases member with a tuple containing all of the
parent objects in the order they should be used to define inheritance.
Remember, all parent-types must have the same C-structure for multiple
inheritance to work properly.</p></li>
<li><p>Call <a class="reference external" href="https://docs.python.org/3/c-api/type.html#c.PyType_Ready" title="(in Python v3.11)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_Ready</span></code></a> (&lt;pointer_to_new_type&gt;). If this function
returns a negative number, a failure occurred and the type is not
initialized. Otherwise, the type is ready to be used. It is
generally important to place a reference to the new type into the
module dictionary so it can be accessed from Python.</p></li>
</ol>
<p>More information on creating sub-types in C can be learned by reading
PEP 253 (available at <a class="reference external" href="https://www.python.org/dev/peps/pep-0253">https://www.python.org/dev/peps/pep-0253</a>).</p>
</section>
<section id="specific-features-of-ndarray-sub-typing">
<span id="specific-array-subtyping"></span><h3>Specific features of ndarray sub-typing<a class="headerlink" href="#specific-features-of-ndarray-sub-typing" title="Permalink to this heading">#</a></h3>
<p>Some special methods and attributes are used by arrays in order to
facilitate the interoperation of sub-types with the base ndarray type.</p>
<section id="the-array-finalize-method">
<h4>The __array_finalize__ method<a class="headerlink" href="#the-array-finalize-method" title="Permalink to this heading">#</a></h4>
<dl class="py attribute">
<dt class="sig sig-object py" id="ndarray.__array_finalize__">
<span class="sig-prename descclassname"><span class="pre">ndarray.</span></span><span class="sig-name descname"><span class="pre">__array_finalize__</span></span><a class="headerlink" href="#ndarray.__array_finalize__" title="Permalink to this definition">#</a></dt>
<dd><p>Several array-creation functions of the ndarray allow
specification of a particular sub-type to be created. This allows
sub-types to be handled seamlessly in many routines. When a
sub-type is created in such a fashion, however, neither the
__new__ method nor the __init__ method gets called. Instead, the
sub-type is allocated and the appropriate instance-structure
members are filled in. Finally, the <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array_finalize__" title="numpy.class.__array_finalize__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_finalize__</span></code></a>
attribute is looked-up in the object dictionary. If it is present and not
None, then it can be either a <a class="reference external" href="https://docs.python.org/3/c-api/capsule.html#c.PyCapsule" title="(in Python v3.11)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a> containing a pointer to a
<a class="reference internal" href="../reference/c-api/array.html#c.PyArray_FinalizeFunc" title="PyArray_FinalizeFunc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_FinalizeFunc</span></code></a> or it can be a method taking a single argument
(which could be None)</p>
<p>If the <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array_finalize__" title="numpy.class.__array_finalize__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_finalize__</span></code></a> attribute is a
<a class="reference external" href="https://docs.python.org/3/c-api/capsule.html#c.PyCapsule" title="(in Python v3.11)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a>, then the pointer must be a pointer to a function with
the signature:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">PyArrayObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The first argument is the newly created sub-type. The second argument
(if not NULL) is the “parent” array (if the array was created using
slicing or some other operation where a clearly-distinguishable parent
is present). This routine can do anything it wants to. It should
return a -1 on error and 0 otherwise.</p>
<p>If the <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array_finalize__" title="numpy.class.__array_finalize__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_finalize__</span></code></a> attribute is not None nor a
<a class="reference external" href="https://docs.python.org/3/c-api/capsule.html#c.PyCapsule" title="(in Python v3.11)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a>, then it must be a Python method that takes the parent
array as an argument (which could be None if there is no parent), and returns
nothing. Errors in this method will be caught and handled.</p>
</dd></dl>

</section>
<section id="the-array-priority-attribute">
<h4>The __array_priority__ attribute<a class="headerlink" href="#the-array-priority-attribute" title="Permalink to this heading">#</a></h4>
<dl class="py attribute">
<dt class="sig sig-object py" id="ndarray.__array_priority__">
<span class="sig-prename descclassname"><span class="pre">ndarray.</span></span><span class="sig-name descname"><span class="pre">__array_priority__</span></span><a class="headerlink" href="#ndarray.__array_priority__" title="Permalink to this definition">#</a></dt>
<dd><p>This attribute allows simple but flexible determination of which sub-
type should be considered “primary” when an operation involving two or
more sub-types arises. In operations where different sub-types are
being used, the sub-type with the largest <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_priority__</span></code></a>
attribute will determine the sub-type of the output(s). If two sub-
types have the same <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_priority__</span></code></a> then the sub-type of the
first argument determines the output. The default
<a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_priority__</span></code></a> attribute returns a value of 0.0 for the base
ndarray type and 1.0 for a sub-type. This attribute can also be
defined by objects that are not sub-types of the ndarray and can be
used to determine which <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array_wrap__" title="numpy.class.__array_wrap__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_wrap__</span></code></a> method should be called for
the return output.</p>
</dd></dl>

</section>
<section id="the-array-wrap-method">
<h4>The __array_wrap__ method<a class="headerlink" href="#the-array-wrap-method" title="Permalink to this heading">#</a></h4>
<dl class="py attribute">
<dt class="sig sig-object py" id="ndarray.__array_wrap__">
<span class="sig-prename descclassname"><span class="pre">ndarray.</span></span><span class="sig-name descname"><span class="pre">__array_wrap__</span></span><a class="headerlink" href="#ndarray.__array_wrap__" title="Permalink to this definition">#</a></dt>
<dd><p>Any class or type can define this method which should take an ndarray
argument and return an instance of the type. It can be seen as the
opposite of the <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array__" title="numpy.class.__array__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array__</span></code></a> method. This method is used by the
ufuncs (and other NumPy functions) to allow other objects to pass
through. For Python &gt;2.4, it can also be used to write a decorator
that converts a function that works only with ndarrays to one that
works with any type with <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array__" title="numpy.class.__array__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array__</span></code></a> and <a class="reference internal" href="../reference/arrays.classes.html#numpy.class.__array_wrap__" title="numpy.class.__array_wrap__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__array_wrap__</span></code></a> methods.</p>
</dd></dl>

<span class="target" id="index-6"></span></section>
</section>
</section>
</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="c-info.ufunc-tutorial.html" title="previous page">
      <i class="fas fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Writing your own ufunc</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="../f2py/index.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">F2PY user guide and reference manual</p>
  </div>
  <i class="fas fa-angle-right"></i>
  </a>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2008-2022, NumPy Developers.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>